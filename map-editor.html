<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Fantasy RTS - ãƒãƒƒãƒ—ã‚¨ãƒ‡ã‚£ã‚¿</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: #0a0f1a;
            color: #e8f0ff;
            height: 100vh;
            overflow: hidden;
        }

        .editor-layout {
            display: flex;
            height: 100vh;
        }

        /* å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ - ãƒ„ãƒ¼ãƒ«ãƒ‘ãƒ¬ãƒƒãƒˆ */
        .tool-sidebar {
            width: 200px;
            background: linear-gradient(180deg, #1a2540, #0f1a30);
            border-right: 2px solid #2a4070;
            display: flex;
            flex-direction: column;
            padding: 12px;
            gap: 12px;
        }

        .sidebar-section {
            background: rgba(30, 45, 70, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.3);
            border-radius: 8px;
            padding: 10px;
        }

        .sidebar-section h3 {
            font-size: 12px;
            color: #8af;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(80, 120, 180, 0.3);
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
        }

        .tool-btn {
            padding: 8px 4px;
            font-size: 11px;
            background: rgba(40, 60, 100, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.4);
            border-radius: 6px;
            color: #ddd;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }

        .tool-btn:hover {
            background: rgba(60, 90, 140, 0.8);
            border-color: #4a7cff;
        }

        .tool-btn.active {
            background: rgba(74, 124, 255, 0.4);
            border-color: #4a7cff;
            color: #fff;
        }

        .terrain-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .terrain-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢ */
        .editor-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-toolbar {
            height: 44px;
            background: #1a2540;
            border-bottom: 1px solid #2a4070;
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 8px;
        }

        .toolbar-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: rgba(40, 60, 100, 0.8);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #ddd;
            cursor: pointer;
            transition: all 0.15s;
        }

        .toolbar-btn:hover {
            background: rgba(60, 90, 140, 0.9);
            border-color: #4a7cff;
        }

        .toolbar-input {
            padding: 4px 8px;
            font-size: 12px;
            background: rgba(20, 30, 50, 0.8);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #e8f0ff;
            width: 120px;
        }

        .toolbar-label {
            font-size: 11px;
            color: #888;
        }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: rgba(80, 120, 180, 0.4);
            margin: 0 8px;
        }

        .canvas-container {
            flex: 1;
            overflow: auto;
            background: #050810;
            position: relative;
        }

        #mapCanvas {
            display: block;
            cursor: crosshair;
        }

        /* å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ - ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ */
        .property-sidebar {
            width: 220px;
            background: linear-gradient(180deg, #1a2540, #0f1a30);
            border-left: 2px solid #2a4070;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }

        .prop-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .prop-label {
            color: #888;
        }

        .prop-value {
            color: #8af;
        }

        .prop-input {
            width: 80px;
            padding: 4px 6px;
            font-size: 11px;
            background: rgba(20, 30, 50, 0.8);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #e8f0ff;
        }

        .height-slider {
            width: 100%;
            margin-top: 4px;
        }

        /* ãƒãƒƒãƒ—ãƒªã‚¹ãƒˆ */
        .map-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 150px;
            overflow-y: auto;
        }

        .map-item {
            padding: 6px 8px;
            font-size: 11px;
            background: rgba(30, 45, 70, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.3);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .map-item:hover {
            background: rgba(50, 70, 110, 0.8);
        }

        .map-item.active {
            background: rgba(74, 124, 255, 0.3);
            border-color: #4a7cff;
        }

        .map-delete-btn {
            float: right;
            color: #d88;
            font-weight: bold;
            cursor: pointer;
            padding: 0 4px;
            border-radius: 4px;
        }

        .map-delete-btn:hover {
            background: rgba(200, 50, 50, 0.4);
            color: #fcc;
        }

        /* åº§æ¨™è¡¨ç¤º */
        .coords-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-size: 11px;
            color: #8af;
            pointer-events: none;
        }

        /* ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        .zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            font-size: 16px;
            background: rgba(40, 60, 100, 0.9);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #ddd;
            cursor: pointer;
        }

        .zoom-btn:hover {
            background: rgba(60, 90, 140, 0.9);
        }

        /* 3Dãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */
        .preview-3d {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 280px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(80, 120, 180, 0.5);
            border-radius: 8px;
            overflow: hidden;
        }

        .preview-3d.expanded {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            height: 90vh;
            z-index: 2000;
            background: rgba(10, 15, 25, 0.95);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 2px solid #4a7cff;
        }

        .preview-3d.expanded canvas {
            width: 100% !important;
            height: calc(100% - 30px) !important;
        }

        .preview-3d-header {
            background: rgba(30, 45, 70, 0.9);
            padding: 4px 8px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #preview3dCanvas {
            width: 100%;
            height: calc(100% - 24px);
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ã®éè¡¨ç¤ºinput */
        .hidden-input {
            display: none;
        }

        /* ãƒ“ãƒ¥ãƒ¼åˆ‡ã‚Šæ›¿ãˆã‚¿ãƒ– */
        .view-tabs {
            display: flex;
            gap: 2px;
        }

        .view-tab {
            padding: 2px 8px;
            font-size: 10px;
            background: rgba(40, 60, 100, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.4);
            border-radius: 3px;
            color: #ddd;
            cursor: pointer;
        }

        /* ãƒ¦ãƒ‹ãƒƒãƒˆãƒªã‚¹ãƒˆ */
        .unit-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            font-size: 11px;
            background: rgba(30, 45, 70, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.3);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            margin-bottom: 4px;
        }

        .unit-list-item:hover {
            background: rgba(50, 70, 110, 0.8);
        }

        .unit-list-item.active {
            background: rgba(74, 124, 255, 0.3);
            border-color: #4a7cff;
        }

        .unit-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .unit-name {
            font-weight: bold;
            color: #adf;
        }

        .unit-details {
            font-size: 10px;
            color: #88aaff;
        }

        .unit-delete-btn {
            color: #d88;
            font-weight: bold;
            cursor: pointer;
            padding: 2px 6px;
        }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 3000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: #1a2540;
            border: 2px solid #4a7cff;
            border-radius: 8px;
            width: 400px;
            padding: 16px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }

        .modal-header {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a4070;
            display: flex;
            justify-content: space-between;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 11px;
            color: #8af;
            margin-bottom: 4px;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 6px;
            background: rgba(10, 15, 25, 0.8);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
        }

        .form-row {
            display: flex;
            gap: 8px;
        }

        .btn-primary {
            background: #4a7cff;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-cancel {
            background: #444;
            color: #ddd;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
        }

        .view-tab.active {
            background: rgba(74, 124, 255, 0.4);
            border-color: #4a7cff;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <!-- Error Logger -->
    <div id="error-log"
        style="display:none; position:fixed; top:0; left:0; width:100%; background:rgba(100,0,0,0.8); color:white; padding:10px; z-index:9999; font-family:monospace; pointer-events:none;">
    </div>
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.getElementById('error-log');
            if (div) {
                div.style.display = 'block';
                div.innerHTML += `<div>Error: ${msg} <br> ${url}:${line}:${col}</div>`;
            }
            console.error(msg, error);
            return false;
        };
        window.addEventListener('unhandledrejection', function (event) {
            const div = document.getElementById('error-log');
            if (div) {
                div.style.display = 'block';
                div.innerHTML += `<div>Promise Error: ${event.reason}</div>`;
            }
            console.error(event.reason);
        });
    </script>
    <div class="editor-layout">
        <!-- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
        <div class="tool-sidebar">
            <div class="sidebar-section">
                <h3>ğŸ–Œï¸ åœ°å½¢ãƒ–ãƒ©ã‚·</h3>
                <div class="tool-grid" id="terrain-tools">
                    <!-- JSã§ç”Ÿæˆ -->
                </div>
            </div>

            <!-- å»ºç‰©ãƒ„ãƒ¼ãƒ« -->
            <div class="sidebar-section">
                <h3>ğŸ  å»ºç‰©</h3>
                <div class="tool-grid" id="building-tools">
                    <!-- JSã§ç”Ÿæˆ -->
                </div>
                <button class="tool-btn" id="btn-rotate" style="width:100%; margin-top:4px;">â†» å›è»¢ (R)</button>

                <div class="sidebar-section">
                    <h3>ğŸ“ é«˜ã•</h3>
                    <div class="prop-row">
                        <span class="prop-label">ãƒ¬ãƒ™ãƒ«</span>
                        <span class="prop-value" id="height-value">0</span>
                    </div>
                    <input type="range" id="height-slider" class="height-slider" min="0" max="10" value="0">
                </div>



                <div class="sidebar-section">
                    <h3>ğŸ”§ ãƒ„ãƒ¼ãƒ«</h3>
                    <div class="tool-grid">
                        <button class="tool-btn" id="tool-select">é¸æŠ</button>
                        <button class="tool-btn active" id="tool-paint">ãƒšã‚¤ãƒ³ãƒˆ</button>
                        <button class="tool-btn" id="tool-fill">å¡—ã‚Šã¤ã¶ã—</button>
                        <button class="tool-btn" id="tool-eraser">æ¶ˆã—ã‚´ãƒ </button>
                        <button class="tool-btn" id="tool-raise" title="é«˜ã•ã‚’ä¸Šã’ã‚‹">ğŸ”¼ éš†èµ·</button>
                        <button class="tool-btn" id="tool-lower" title="é«˜ã•ã‚’ä¸‹ã’ã‚‹">ğŸ”½ æ²ˆé™</button>
                        <button class="tool-btn" id="tool-smooth" title="æ»‘ã‚‰ã‹ã«ã™ã‚‹">ã€°ï¸ æ•´åœ°</button>
                    </div>
                </div>
            </div>

        </div>

        <!-- ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ -->
        <div class="editor-main">
            <div class="editor-toolbar">
                <button class="toolbar-btn" id="btn-new">æ–°è¦</button>
                <div class="toolbar-separator"></div>

                <!-- ä¿å­˜ãƒ»èª­è¾¼ç³» -->
                <button class="toolbar-btn" id="btn-export"
                    style="background:#4a7cff; border-color:#8af; font-weight:bold;" title="JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰">ğŸ“¤
                    ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜</button>
                <button class="toolbar-btn" id="btn-load-file" title="JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒãƒƒãƒ—ã‚’èª­ã¿è¾¼ã‚€">ğŸ“‚
                    ãƒ•ã‚¡ã‚¤ãƒ«èª­è¾¼</button>

                <div class="toolbar-separator"></div>
                <span class="toolbar-label">ã‚µã‚¤ã‚º:</span>
                <input type="number" class="toolbar-input" id="map-width" value="30" min="10" max="100"
                    style="width:40px">
                <span class="toolbar-label">Ã—</span>
                <input type="number" class="toolbar-input" id="map-height" value="30" min="10" max="100"
                    style="width:40px">
                <button class="toolbar-btn" id="btn-resize">é©ç”¨</button>
                <div class="toolbar-separator"></div>
                <span class="toolbar-label">ãƒãƒƒãƒ—å:</span>
                <input type="text" class="toolbar-input" id="map-name" value="æ–°è¦ãƒãƒƒãƒ—" style="width:100px;">
                <button class="toolbar-btn" id="btn-generate-terrain"
                    style="background:rgba(100, 150, 100, 0.6); border-color:#8f8;" title="ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ«ç”Ÿæˆ">ğŸ”ï¸ è‡ªå‹•ç”Ÿæˆ</button>
                <div class="toolbar-separator"></div>

                <!-- ãƒ„ãƒ¼ãƒ« -->
                <button class="toolbar-btn" id="btn-import-heightmap">ğŸ“· æ¨™é«˜ç”»åƒ</button>
                <label style="font-size:11px; color:#aaa; margin-left:4px;"><input type="checkbox" id="chk-smooth"
                        checked> è£œæ­£</label>
                <button class="toolbar-btn" id="btn-import-terrain">ğŸ¨ åœ°å½¢ç”»åƒ</button>
                <button class="toolbar-btn" id="btn-import-watermask" title="ç™½=æ°´åŸŸ(æµ·ãƒ»æ¹–)ã€ã‚°ãƒ¬ãƒ¼=å·ã€é»’=å¤‰æ›´ãªã—"
                    style="background:rgba(30,80,160,0.5); border-color:#4af;">ğŸ’§ æ°´ãƒã‚¹ã‚¯</button>

                <a href="./building-designer.html" target="_blank" class="toolbar-btn"
                    style="text-decoration:none; display:inline-block; text-align:center;">ğŸ”¨ å»ºé€ ç‰©ã‚¨ãƒ‡ã‚£ã‚¿</a>
                <button class="toolbar-btn" id="btn-import-clipboard"
                    style="background:rgba(100,200,100,0.3); border-color:#8f8;">ğŸ“‹ JSONè²¼ä»˜</button>

                <input type="file" id="heightmap-input" class="hidden-input" accept="image/*">
                <input type="file" id="terrain-input" class="hidden-input" accept="image/*">
                <input type="file" id="watermask-input" class="hidden-input" accept="image/*">
                <input type="file" id="map-json-input" class="hidden-input" accept=".json">
            </div>

            <div class="canvas-container">
                <canvas id="mapCanvas"></canvas>
                <div class="coords-display" id="coords-display">X: 0, Y: 0</div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-out">âˆ’</button>
                    <button class="zoom-btn" id="zoom-in">ï¼‹</button>
                </div>
                <!-- 3Dãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼çª“ -->
                <div class="preview-3d" id="preview-3d">
                    <div class="preview-3d-header">
                        <span>ğŸ¨ 3Dãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</span>
                        <div class="view-tabs">
                            <button class="view-tab active" id="view-perspective">æ–œã‚</button>
                            <button class="view-tab" id="view-top">çœŸä¸Š</button>
                            <button class="view-tab" id="view-rotate" style="margin-left:5px">ğŸ”„</button>
                            <button class="view-tab" id="view-expand" style="margin-left:5px">â¤¢</button>
                        </div>
                    </div>
                    <canvas id="preview3dCanvas"></canvas>
                </div>
            </div>
        </div>

        <!-- å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
        <div class="property-sidebar">
            <div class="sidebar-section">
                <h3>ğŸ“‹ ãƒãƒƒãƒ—æƒ…å ±</h3>
                <div class="prop-row">
                    <span class="prop-label">ã‚µã‚¤ã‚º</span>
                    <span class="prop-value" id="info-size">30 Ã— 30</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">å»ºé€ ç‰©</span>
                    <span class="prop-value" id="info-buildings">0</span>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>ğŸ“ ä¿å­˜æ¸ˆã¿ãƒãƒƒãƒ—</h3>
                <div class="map-list" id="map-list">
                    <!-- JSã§ç”Ÿæˆ -->
                </div>
            </div>

            <div class="sidebar-section">
                <h3>ğŸ¯ é…ç½®ã‚¨ãƒªã‚¢</h3>
                <div class="prop-row">
                    <span class="prop-label">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</span>
                    <button class="toolbar-btn" id="btn-set-player-zone" style="font-size:10px">è¨­å®š</button>
                </div>
                <div class="prop-row">
                    <span class="prop-label">æ•µ</span>
                    <button class="toolbar-btn" id="btn-set-enemy-zone" style="font-size:10px">è¨­å®š</button>
                </div>
            </div>

            <div class="sidebar-section">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <h3>âš”ï¸ æ•µãƒ¦ãƒ‹ãƒƒãƒˆå®šç¾©</h3>
                    <button class="tool-btn" id="btn-add-unit" style="font-size:10px; padding:2px 6px;">ï¼‹æ–°è¦</button>
                </div>
                <div class="map-list" id="unit-list" style="margin-top:8px;">
                    <!-- JSã§ç”Ÿæˆ -->
                </div>
                <div style="margin-top:8px; font-size:10px; color:#888;">
                    ãƒªã‚¹ãƒˆã‹ã‚‰é¸æŠã—ã¦ãƒšã‚¤ãƒ³ãƒˆã§é…ç½®
                </div>
            </div>
        </div>
    </div>

    <!-- åœ°å½¢ç”Ÿæˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div class="modal-overlay" id="terrain-modal">
        <div class="modal-content" style="width: 450px;">
            <div class="modal-header">
                <span>è‡ªå‹•åœ°å½¢ç”Ÿæˆ</span>
                <span style="cursor:pointer;" id="btn-close-terrain-modal">Ã—</span>
            </div>
            <div class="form-group">
                <label class="form-label">ãƒ—ãƒªã‚»ãƒƒãƒˆ</label>
                <div style="display:flex; gap:12px; flex-wrap:wrap;">
                    <label style="cursor:pointer"><input type="radio" name="terrain-preset" value="flat" checked>
                        å¹³å¦(ã‚¯ãƒªã‚¢)</label>
                    <label style="cursor:pointer"><input type="radio" name="terrain-preset" value="slope"> å‚</label>
                    <label style="cursor:pointer"><input type="radio" name="terrain-preset" value="hill"> ä¸˜</label>
                    <label style="cursor:pointer"><input type="radio" name="terrain-preset" value="valley"> è°·</label>
                    <label style="cursor:pointer"><input type="radio" name="terrain-preset" value="terrace"> æ®µä¸˜</label>
                    <label style="cursor:pointer"><input type="radio" name="terrain-preset" value="random"> ãƒ©ãƒ³ãƒ€ãƒ </label>
                </div>
            </div>

            <div id="terrain-options">
                <div class="form-group" id="opt-direction">
                    <label class="form-label">æ–¹å‘</label>
                    <div style="display:flex; gap:8px;">
                        <select class="form-select" id="terrain-direction" style="flex:1">
                            <option value="n">åŒ—ãŒé«˜ã„ (â†‘)</option>
                            <option value="s">å—ãŒé«˜ã„ (â†“)</option>
                            <option value="e">æ±ãŒé«˜ã„ (â†’)</option>
                            <option value="w">è¥¿ãŒé«˜ã„ (â†)</option>
                        </select>
                        <select class="form-select" id="terrain-valley-axis" style="flex:1; display:none;">
                            <option value="x">æ±è¥¿ã«ä¼¸ã³ã‚‹ (å—åŒ—ãŒé«˜ã„)</option>
                            <option value="y">å—åŒ—ã«ä¼¸ã³ã‚‹ (æ±è¥¿ãŒé«˜ã„)</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">é«˜ã•å¼·åº¦ / å¤‰åŒ–é‡ (1-10)</label>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <input type="range" id="terrain-intensity" min="1" max="10" value="5" style="flex:1">
                        <span id="terrain-intensity-val"
                            style="width:20px; text-align:right; font-size:12px; color:#8af">5</span>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">ãƒ™ãƒ¼ã‚¹ã®é«˜ã• (0-5)</label>
                    <input type="number" class="form-input" id="terrain-base-height" min="0" max="10" value="0">
                </div>

                <div class="form-group">
                    <label class="form-label">é©ç”¨ç¯„å›²</label>
                    <div style="display:flex; gap:12px;">
                        <label style="cursor:pointer"><input type="checkbox" id="terrain-keep-buildings" checked>
                            å»ºç‰©ã‚’ç¶­æŒ</label>
                        <label style="cursor:pointer"><input type="checkbox" id="terrain-keep-units" checked>
                            ãƒ¦ãƒ‹ãƒƒãƒˆã‚’ç¶­æŒ</label>
                    </div>
                </div>
            </div>

            <div style="text-align:right; margin-top:16px;">
                <button class="btn-cancel" id="btn-cancel-terrain">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="btn-primary" id="btn-exec-terrain">ç”Ÿæˆå®Ÿè¡Œ</button>
            </div>
        </div>
    </div>

    <!-- æ¨™é«˜å›³ã‚¤ãƒ³ãƒãƒ¼ãƒˆè¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚° -->
    <div class="modal-overlay" id="heightmap-settings-modal">
        <div class="modal-content" style="width: 480px;">
            <div class="modal-header">
                <span>ğŸ“· æ¨™é«˜å›³ã‚¤ãƒ³ãƒãƒ¼ãƒˆè¨­å®š</span>
                <span style="cursor:pointer;" id="btn-close-heightmap-modal">Ã—</span>
            </div>
            <div
                style="font-size:11px; color:#8af; margin-bottom:12px; padding:8px; background:rgba(74,124,255,0.1); border-radius:4px; border:1px solid rgba(74,124,255,0.3);">
                é«˜ã•ï¼ˆ0ã€œ10ï¼‰ã‚’ã©ã®åœ°å½¢ã‚¿ã‚¤ãƒ—ã¨ã—ã¦æ‰±ã†ã‹æŒ‡å®šã—ã¾ã™ã€‚<br>
                æ°´åŸŸã¯ã€ŒğŸ’§ æ°´ãƒã‚¹ã‚¯ã€ã§åˆ¥é€”è¨­å®šã—ã¦ãã ã•ã„ã€‚
            </div>

            <!-- é–¾å€¤è¨­å®š -->
            <div style="margin-bottom:12px;">
                <div
                    style="font-size:12px; font-weight:bold; color:#cde; margin-bottom:8px; padding-bottom:4px; border-bottom:1px solid rgba(80,120,180,0.3);">
                    é«˜ã• â†’ åœ°å½¢ã‚¿ã‚¤ãƒ— ãƒãƒƒãƒ”ãƒ³ã‚°</div>

                <!-- ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒãƒ¼ -->
                <div id="hm-gradient-bar"
                    style="height:18px; border-radius:4px; margin-bottom:10px; background: linear-gradient(to right, #4a7c41, #4a7c41, #2d5a27, #7a6b5a, #4a4a4a); border:1px solid rgba(255,255,255,0.2);">
                </div>

                <div style="display:grid; grid-template-columns: 1fr auto auto; gap:6px 10px; align-items:center;">
                    <!-- è‰åŸ -->
                    <div style="font-size:12px; display:flex; align-items:center; gap:6px;">
                        <span
                            style="display:inline-block; width:14px; height:14px; background:#4a7c41; border-radius:2px; border:1px solid rgba(255,255,255,0.3);"></span>
                        è‰åŸï¼ˆgrassï¼‰ â€” ã‚³ã‚¹ãƒˆ1
                    </div>
                    <span style="font-size:11px; color:#888;">é«˜ã•</span>
                    <div style="display:flex; align-items:center; gap:4px; font-size:12px;">
                        <input type="number" id="hm-grass-min" min="0" max="10" value="1"
                            style="width:44px; padding:3px 5px; background:rgba(20,30,50,0.8); border:1px solid rgba(80,120,180,0.5); border-radius:4px; color:#e8f0ff; font-size:12px;">
                        <span style="color:#888;">ã€œ</span>
                        <input type="number" id="hm-grass-max" min="0" max="10" value="3"
                            style="width:44px; padding:3px 5px; background:rgba(20,30,50,0.8); border:1px solid rgba(80,120,180,0.5); border-radius:4px; color:#e8f0ff; font-size:12px;">
                    </div>

                    <!-- æ£® -->
                    <div style="font-size:12px; display:flex; align-items:center; gap:6px;">
                        <span
                            style="display:inline-block; width:14px; height:14px; background:#2d5a27; border-radius:2px; border:1px solid rgba(255,255,255,0.3);"></span>
                        æ£®ï¼ˆforestï¼‰ â€” ã‚³ã‚¹ãƒˆ1.5
                    </div>
                    <span style="font-size:11px; color:#888;">é«˜ã•</span>
                    <div style="display:flex; align-items:center; gap:4px; font-size:12px;">
                        <input type="number" id="hm-forest-min" min="0" max="10" value="4"
                            style="width:44px; padding:3px 5px; background:rgba(20,30,50,0.8); border:1px solid rgba(80,120,180,0.5); border-radius:4px; color:#e8f0ff; font-size:12px;">
                        <span style="color:#888;">ã€œ</span>
                        <input type="number" id="hm-forest-max" min="0" max="10" value="5"
                            style="width:44px; padding:3px 5px; background:rgba(20,30,50,0.8); border:1px solid rgba(80,120,180,0.5); border-radius:4px; color:#e8f0ff; font-size:12px;">
                    </div>

                    <!-- å±± -->
                    <div style="font-size:12px; display:flex; align-items:center; gap:6px;">
                        <span
                            style="display:inline-block; width:14px; height:14px; background:#7a6b5a; border-radius:2px; border:1px solid rgba(255,255,255,0.3);"></span>
                        å±±ï¼ˆmountainï¼‰ â€” ã‚³ã‚¹ãƒˆ2
                    </div>
                    <span style="font-size:11px; color:#888;">é«˜ã•</span>
                    <div style="display:flex; align-items:center; gap:4px; font-size:12px;">
                        <input type="number" id="hm-mountain-min" min="0" max="10" value="6"
                            style="width:44px; padding:3px 5px; background:rgba(20,30,50,0.8); border:1px solid rgba(80,120,180,0.5); border-radius:4px; color:#e8f0ff; font-size:12px;">
                        <span style="color:#888;">ã€œ</span>
                        <input type="number" id="hm-mountain-max" min="0" max="10" value="8"
                            style="width:44px; padding:3px 5px; background:rgba(20,30,50,0.8); border:1px solid rgba(80,120,180,0.5); border-radius:4px; color:#e8f0ff; font-size:12px;">
                    </div>

                    <!-- å´– -->
                    <div style="font-size:12px; display:flex; align-items:center; gap:6px;">
                        <span
                            style="display:inline-block; width:14px; height:14px; background:#4a4a4a; border-radius:2px; border:1px solid rgba(255,255,255,0.3);"></span>
                        å´–ï¼ˆcliffï¼‰ â€” ä¾µå…¥ä¸å¯
                    </div>
                    <span style="font-size:11px; color:#888;">é«˜ã•</span>
                    <div style="display:flex; align-items:center; gap:4px; font-size:12px;">
                        <input type="number" id="hm-cliff-min" min="0" max="10" value="9"
                            style="width:44px; padding:3px 5px; background:rgba(20,30,50,0.8); border:1px solid rgba(80,120,180,0.5); border-radius:4px; color:#e8f0ff; font-size:12px;">
                        <span style="color:#888;">ã€œ</span>
                        <span style="font-size:12px; color:#8af; min-width:44px;">10ï¼ˆä¸Šé™ï¼‰</span>
                    </div>
                </div>
                <div style="font-size:10px; color:#888; margin-top:8px;">
                    â€» è‰åŸç¯„å›²å¤–ï¼ˆãã‚Œä»¥ä¸‹/ä»¥ä¸Šï¼‰ã§å‰²ã‚Šå½“ã¦ãªã— â†’ è‰åŸï¼ˆgrassï¼‰ã¨ã—ã¦æ‰±ã„ã¾ã™
                </div>
            </div>

            <!-- ã‚¹ãƒ ãƒ¼ãƒ“ãƒ³ã‚°ã‚ªãƒ—ã‚·ãƒ§ãƒ³ -->
            <div class="form-group">
                <label style="cursor:pointer; font-size:12px; display:flex; align-items:center; gap:6px;">
                    <input type="checkbox" id="hm-smooth" checked> é«˜ã•è£œæ­£ï¼ˆ3Ã—3 å¹³å‡ãƒ•ã‚£ãƒ«ã‚¿ï¼‰ã‚’é©ç”¨
                </label>
            </div>

            <div style="text-align:right; margin-top:16px;">
                <button class="btn-cancel" id="btn-cancel-heightmap">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="btn-primary" id="btn-exec-heightmap">é©ç”¨</button>
            </div>
        </div>
    </div>

    <!-- ãƒ¦ãƒ‹ãƒƒãƒˆå®šç¾©ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div class="modal-overlay" id="unit-modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>æ•µãƒ¦ãƒ‹ãƒƒãƒˆå®šç¾©ç·¨é›†</span>
                <span style="cursor:pointer;" id="btn-close-unit-modal">Ã—</span>
            </div>
            <div class="form-group">
                <label class="form-label">åå‰ (å…¨è§’10æ–‡å­—ä»¥å†…)</label>
                <input type="text" class="form-input" id="unit-name" maxlength="10" placeholder="ä¾‹: ã‚´ãƒ–ãƒªãƒ³éƒ¨éšŠ">
            </div>
            <div class="form-group">
                <label class="form-label">ç«‹å ´</label>
                <div style="display:flex; gap:12px; align-items:center; font-size:12px;">
                    <label><input type="radio" name="unit-role" value="normal" checked> ä¸€èˆ¬å…µ</label>
                    <label><input type="radio" name="unit-role" value="commander"> æŒ‡æ®å®˜</label>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">ãƒ¦ãƒ‹ãƒƒãƒˆç¨®é¡</label>
                <select class="form-select" id="unit-type">
                    <!-- JSã§è‡ªå‹•ç”Ÿæˆ -->
                </select>
            </div>
            <div class="form-row">
                <div class="form-group" style="flex:1;">
                    <label class="form-label">ãƒ¦ãƒ‹ãƒƒãƒˆæ•° (1-30)</label>
                    <input type="number" class="form-input" id="unit-count" min="1" max="30" value="10">
                </div>
                <div class="form-group" style="flex:1;">
                    <label class="form-label">ãƒ¬ãƒ™ãƒ« (1-99)</label>
                    <input type="number" class="form-input" id="unit-level" min="1" max="99" value="99">
                </div>
                <div class="form-group" style="flex:1;">
                    <label class="form-label">æœ€å¤§HP</label>
                    <input type="number" class="form-input" id="unit-hp" min="1" max="9999" value="1000">
                </div>
            </div>
            <div style="text-align:right; margin-top:8px;">
                <button class="btn-cancel" id="btn-cancel-unit">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="btn-primary" id="btn-save-unit">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { mapRepository, TERRAIN_TYPES, compressBlocks, decompressBlocks } from './scripts/map-repository.js';
        import { BUILDING_TEMPLATES, BLOCK_TYPES, BLOCK_COLORS } from './scripts/building.js';
        import { UNIT_TYPES } from './scripts/constants.js';

        class MapEditor {
            constructor() {
                this.canvas = document.getElementById('mapCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.currentMapId = null;
                this.currentTool = 'paint';
                this.currentTerrain = 'grass';
                this.currentHeight = 0;
                this.currentBuilding = null;

                this.cellSize = 20;
                this.zoom = 1;
                this.offsetX = 0;
                this.offsetY = 0;

                // 3D Preview State
                this.viewRotation = 0; // 0, 1, 2, 3 (x90 deg)
                this.currentRotation = 0; // Building rotation: 0, 1, 2, 3

                this.isMouseDown = false;
                this.lastCell = null;

                // é…ç½®ã‚¨ãƒªã‚¢è¨­å®šç”¨
                // playerDeploymentZones ã¯ map.playerDeploymentZones ã‚’ç›´æ¥ä½¿ç”¨
                this.deploymentMode = null;        // 'player' | 'enemy' | null
                this.fileHandle = null; // File System Access API Handle

                this.init();
            }

            get currentMap() {
                return mapRepository.get(this.currentMapId);
            }

            getTemplate(typeId) {
                if (this.templateCache && this.templateCache[typeId]) return this.templateCache[typeId];

                if (BUILDING_TEMPLATES[typeId]) return BUILDING_TEMPLATES[typeId];

                if (this.registeredCustomBuildings) {
                    const found = this.registeredCustomBuildings.find(cb => cb.id === typeId);
                    if (found) {
                        const data = found.data;
                        let blocks = data.blocks;

                        // Decompress if needed
                        if (!blocks && data.compressedBlocks) {
                            blocks = decompressBlocks(data.compressedBlocks, data.size);
                        }

                        const tmpl = { ...data, name: found.name, blocks: blocks };

                        if (!this.templateCache) this.templateCache = {};
                        this.templateCache[typeId] = tmpl;
                        return tmpl;
                    }
                }
                return null;
            }

            init() {
                this.generateTerrainButtons();
                this.generateBuildingButtons();
                this.setupEventListeners();

                // ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
                const hasData = mapRepository.loadFromStorage();

                // Load sample maps from files (async)
                this.autoLoadSamples();

                // ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆï¼ˆåˆå›èµ·å‹•ãªã©ï¼‰ã¯ã‚µãƒ³ãƒ—ãƒ«ãƒãƒƒãƒ—ã‚’ä½œæˆ
                // ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆï¼ˆåˆå›èµ·å‹•ãªã©ï¼‰ã¯ã‚µãƒ³ãƒ—ãƒ«ãƒãƒƒãƒ—ã‚’ä½œæˆ (å»ƒæ­¢: autoLoadSamplesã‚’ä½¿ç”¨)
                // if (!hasData) {
                //     createSampleMaps();
                // }

                this.refreshMapList();

                // ãƒãƒƒãƒ—ãƒªã‚¹ãƒˆãŒã‚ã‚‹å ´åˆã¯å…ˆé ­ï¼ˆæœ€å¾Œã«ä¿å­˜ã•ã‚ŒãŸã‚‚ã®ãªã©ï¼‰ã‚’é–‹ãã€ãªã‘ã‚Œã°æ–°è¦ä½œæˆ
                const maps = mapRepository.list();
                if (maps.length > 0) {
                    // æœ€æ–°é †ã«ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‹ã¯å®Ÿè£…ä¾å­˜ã ãŒã€ãƒªã‚¹ãƒˆã®å…ˆé ­ã‚’é–‹ã
                    this.loadMap(maps[0].id);
                } else {
                    this.createNewMap();
                }
            }

            generateTerrainButtons() {
                const container = document.getElementById('terrain-tools');
                container.innerHTML = '';

                Object.values(TERRAIN_TYPES).forEach(terrain => {
                    const btn = document.createElement('button');
                    btn.className = 'tool-btn terrain-btn';
                    btn.dataset.terrain = terrain.id;
                    btn.innerHTML = `
                        <div class="terrain-color" style="background:${terrain.color}"></div>
                        <span>${terrain.name}</span>
                    `;
                    btn.addEventListener('click', () => this.selectTerrain(terrain.id));
                    container.appendChild(btn);
                });
            }

            generateBuildingButtons() {
                const container = document.getElementById('building-tools');
                container.innerHTML = '';

                // Standard Templates
                Object.keys(BUILDING_TEMPLATES).forEach(key => {
                    const tmpl = BUILDING_TEMPLATES[key];
                    this.createBuildingBtn(container, key, tmpl.name);
                });

                // Custom Templates
                if (this.registeredCustomBuildings) {
                    this.registeredCustomBuildings.forEach(cb => {
                        this.createBuildingBtn(container, cb.id, cb.name, true);
                    });
                }
            }

            createBuildingBtn(container, key, name, isCustom = false) {
                const btn = document.createElement('button');
                btn.className = 'tool-btn building-btn';
                if (isCustom) {
                    btn.style.border = '1px solid #4a7cff';
                    btn.title = 'å³ã‚¯ãƒªãƒƒã‚¯ã§å‰Šé™¤';
                    btn.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        this.deleteCustomBuilding(key, name);
                    });
                }
                btn.dataset.building = key;
                btn.innerHTML = `<span>${name}</span>`;
                btn.addEventListener('click', () => this.selectBuilding(key));
                container.appendChild(btn);
            }

            selectTerrain(terrainId) {
                this.currentTool = 'paint';
                this.currentTerrain = terrainId;

                // ãƒ„ãƒ¼ãƒ«çŠ¶æ…‹æ›´æ–°
                // update active state in toolbar
                document.querySelectorAll('.tool-btn, .toolbar-btn').forEach(btn => btn.classList.remove('active'));
                const paintBtn = document.getElementById('tool-paint');
                if (paintBtn) paintBtn.classList.add('active');

                // UIæ›´æ–°
                document.querySelectorAll('.terrain-btn').forEach(btn => {
                    if (btn.dataset.terrain === terrainId) {
                        btn.style.borderColor = '#4a7cff';
                        btn.style.background = 'rgba(74, 124, 255, 0.4)';
                    } else {
                        btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                        btn.style.background = ''; // reset or keep default class style? relies on class 'active' usually.
                    }
                });

                // class 'active' is better if CSS handles it
                // Re-doing with class toggle based on previous CSS view
                document.querySelectorAll('.terrain-btn').forEach(btn => {
                    if (btn.dataset.terrain === terrainId) btn.classList.add('active');
                    else btn.classList.remove('active');
                });

                // å»ºç‰©ãƒ»ãƒ¦ãƒ‹ãƒƒãƒˆé¸æŠè§£é™¤
                this.currentBuilding = null;
                this.currentUnitDefId = null;
                document.querySelectorAll('.building-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.unit-list-item').forEach(btn => btn.classList.remove('active'));
            }

            selectBuilding(buildingId) {
                this.currentTool = 'building';
                this.currentBuilding = buildingId;
                this.currentUnitDefId = null;

                // ãƒ„ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã®é¸æŠçŠ¶æ…‹è§£é™¤
                document.querySelectorAll('#tool-select, #tool-paint, #tool-fill, #tool-eraser, #tool-raise, #tool-lower, #tool-smooth').forEach(btn => {
                    btn.classList.remove('active');
                });

                // UIæ›´æ–°
                document.querySelectorAll('.building-btn').forEach(btn => {
                    if (btn.dataset.building === buildingId) btn.classList.add('active');
                    else btn.classList.remove('active');
                });

                // ä»–ã®é¸æŠè§£é™¤
                document.querySelectorAll('.terrain-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.unit-list-item').forEach(btn => btn.classList.remove('active'));
            }

            rotateBuilding() {
                if (this.currentTool !== 'building' || !this.currentBuilding) {
                    this.currentRotation = (this.currentRotation + 1) % 4;
                    return;
                }
                this.currentRotation = (this.currentRotation + 1) % 4;
                this.render();
                this.update3DPreviewDebounced();
            }

            setupEventListeners() {
                // Canvas events
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.isMouseDown = false);
                this.canvas.addEventListener('mouseleave', () => this.isMouseDown = false);
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    // å³ã‚¯ãƒªãƒƒã‚¯å‡¦ç†ã¯ onMouseDown ã§è¡Œã†ãŸã‚ã€ã“ã“ã§ã¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼æŠ‘åˆ¶ã®ã¿
                });

                // Tool buttons
                document.getElementById('tool-paint').addEventListener('click', () => this.setTool('paint'));
                document.getElementById('tool-select').addEventListener('click', () => this.setTool('select'));
                document.getElementById('tool-fill').addEventListener('click', () => this.setTool('fill'));
                document.getElementById('tool-eraser').addEventListener('click', () => this.setTool('eraser'));
                document.getElementById('tool-raise').addEventListener('click', () => this.setTool('raise'));
                document.getElementById('tool-lower').addEventListener('click', () => this.setTool('lower'));
                document.getElementById('tool-smooth').addEventListener('click', () => this.setTool('smooth'));
                document.getElementById('btn-rotate').addEventListener('click', () => this.rotateBuilding());

                // Terrain Generator
                document.getElementById('btn-generate-terrain').addEventListener('click', () => {
                    document.getElementById('terrain-modal').style.display = 'flex';
                });
                document.getElementById('btn-close-terrain-modal').addEventListener('click', () => {
                    document.getElementById('terrain-modal').style.display = 'none';
                });
                document.getElementById('btn-cancel-terrain').addEventListener('click', () => {
                    document.getElementById('terrain-modal').style.display = 'none';
                });
                document.getElementById('btn-exec-terrain').addEventListener('click', () => {
                    this.executeTerrainGeneration();
                    document.getElementById('terrain-modal').style.display = 'none';
                });

                // Terrain Generator Options Logic
                const terrainPresets = document.getElementsByName('terrain-preset');
                terrainPresets.forEach(radio => {
                    radio.addEventListener('change', () => {
                        const val = radio.value;
                        const optDir = document.getElementById('opt-direction');
                        if (val === 'slope') {
                            optDir.style.display = 'block';
                            document.getElementById('terrain-direction').style.display = 'block';
                            document.getElementById('terrain-valley-axis').style.display = 'none';
                        } else if (val === 'valley') {
                            optDir.style.display = 'block';
                            document.getElementById('terrain-direction').style.display = 'none';
                            document.getElementById('terrain-valley-axis').style.display = 'block';
                        } else {
                            // hill, terrace, random, flat ã¯æ–¹å‘/è»¸ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¸è¦
                            optDir.style.display = 'none';
                        }
                    });
                });
                document.getElementById('terrain-intensity').addEventListener('input', (e) => {
                    document.getElementById('terrain-intensity-val').textContent = e.target.value;
                });

                // Key binding
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'r') {
                        this.rotateBuilding();
                    }
                });

                // Height slider
                document.getElementById('height-slider').addEventListener('input', (e) => {
                    this.currentHeight = parseInt(e.target.value);
                    document.getElementById('height-value').textContent = this.currentHeight;
                });

                // Toolbar buttons
                document.getElementById('btn-new').addEventListener('click', () => this.createNewMap());
                document.getElementById('btn-resize').addEventListener('click', () => this.resizeMap());
                document.getElementById('btn-export').addEventListener('click', (e) => {
                    // ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ï¼ˆå¸¸ã«åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜ï¼‰
                    this.exportToJson(false);
                });

                // File load logic
                document.getElementById('btn-load-file').addEventListener('click', () => {
                    document.getElementById('map-json-input').click();
                });

                // Add Open Project listener
                const btnOpenProject = document.getElementById('btn-open-project'); // You might need to add this button to HTML
                if (btnOpenProject) {
                    btnOpenProject.addEventListener('click', () => this.openProject());
                }

                document.getElementById('map-json-input').addEventListener('change', (e) => {
                    this.importFromJsonFile(e.target.files[0]);
                    e.target.value = ''; // Reset
                });

                // Heightmap import - ãƒ€ã‚¤ã‚¢ãƒ­ã‚°çµŒç”±
                document.getElementById('btn-import-heightmap').addEventListener('click', () => {
                    document.getElementById('heightmap-input').click();
                });
                document.getElementById('heightmap-input').addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        this._pendingHeightmapFile = e.target.files[0];
                        // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤ºã™ã‚‹å‰ã«smoothãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å€¤ã‚’åŒæœŸ
                        const chkSmooth = document.getElementById('chk-smooth');
                        document.getElementById('hm-smooth').checked = chkSmooth ? chkSmooth.checked : true;
                        document.getElementById('heightmap-settings-modal').classList.add('active');
                    }
                    e.target.value = ''; // Reset
                });
                document.getElementById('btn-close-heightmap-modal').addEventListener('click', () => {
                    document.getElementById('heightmap-settings-modal').classList.remove('active');
                    this._pendingHeightmapFile = null;
                });
                document.getElementById('btn-cancel-heightmap').addEventListener('click', () => {
                    document.getElementById('heightmap-settings-modal').classList.remove('active');
                    this._pendingHeightmapFile = null;
                });
                document.getElementById('btn-exec-heightmap').addEventListener('click', () => {
                    document.getElementById('heightmap-settings-modal').classList.remove('active');
                    if (this._pendingHeightmapFile) {
                        this.importHeightmap(this._pendingHeightmapFile);
                        this._pendingHeightmapFile = null;
                    }
                });

                // Terrain image import
                document.getElementById('btn-import-terrain').addEventListener('click', () => {
                    document.getElementById('terrain-input').click();
                });
                document.getElementById('terrain-input').addEventListener('change', (e) => {
                    this.importTerrainImage(e.target.files[0]);
                });

                // Water mask import
                document.getElementById('btn-import-watermask').addEventListener('click', () => {
                    document.getElementById('watermask-input').click();
                });
                document.getElementById('watermask-input').addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        this.importWaterMask(e.target.files[0]);
                        e.target.value = '';
                    }
                });

                // 3D Preview view toggle
                document.getElementById('view-perspective').addEventListener('click', () => {
                    this.set3DView('perspective');
                });
                document.getElementById('view-top').addEventListener('click', () => {
                    this.set3DView('top');
                });
                document.getElementById('view-rotate').addEventListener('click', () => {
                    this.rotate3DView();
                });
                document.getElementById('view-expand').addEventListener('click', () => {
                    this.togglePreviewExpand();
                });

                // JSON Import - Duplicate removed
                // document.getElementById('map-json-input').addEventListener('change', ... is already handled above calling importFromJsonFile


                // Clipboard Import
                document.getElementById('btn-import-clipboard').addEventListener('click', async () => {
                    let jsonText = '';
                    try {
                        jsonText = await navigator.clipboard.readText();
                    } catch (e) {
                        // Fallback
                    }

                    if (!jsonText) {
                        jsonText = prompt("å»ºé€ ç‰©JSONãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„");
                    }

                    if (jsonText) {
                        try {
                            const data = JSON.parse(jsonText);
                            if (data.blocks && data.size) {
                                this.registerCustomBuilding(data);
                            } else {
                                alert("ç„¡åŠ¹ãªå»ºé€ ç‰©ãƒ‡ãƒ¼ã‚¿ã§ã™ (blocks, size ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå¿…è¦ã§ã™)");
                            }
                        } catch (e) {
                            alert("JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: " + e.message);
                        }
                    }
                });

                // Zoom
                document.getElementById('zoom-in').addEventListener('click', () => this.setZoom(this.zoom + 0.2));
                document.getElementById('zoom-out').addEventListener('click', () => this.setZoom(this.zoom - 0.2));

                // Initialize 3D preview
                this.init3DPreview();

                // Unit Editor Events
                document.getElementById('btn-add-unit').addEventListener('click', () => this.openUnitModal());
                document.getElementById('btn-close-unit-modal').addEventListener('click', () => this.closeUnitModal());
                document.getElementById('btn-cancel-unit').addEventListener('click', () => this.closeUnitModal());
                document.getElementById('btn-save-unit').addEventListener('click', () => this.saveUnitDefinition());

                // Custom Building Import Message (window.opener)
                window.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'DEPLOY_BUILDING') {
                        console.log('Received custom building (postMessage):', event.data.data);
                        this.registerCustomBuilding(event.data.data);
                    }
                });

                // Custom Building Import Message (BroadcastChannel)
                try {
                    const channel = new BroadcastChannel('fantasy-rts-editor');
                    channel.onmessage = (event) => {
                        if (event.data && event.data.type === 'DEPLOY_BUILDING') {
                            console.log('Received custom building (BroadcastChannel):', event.data.data);
                            this.registerCustomBuilding(event.data.data);
                        }
                    };
                } catch (e) {
                    console.warn("BroadcastChannel support missing", e);
                }

                // é…ç½®ã‚¨ãƒªã‚¢è¨­å®šãƒœã‚¿ãƒ³
                document.getElementById('btn-set-player-zone').addEventListener('click', () => {
                    this.toggleDeploymentMode('player');
                });
                document.getElementById('btn-set-enemy-zone').addEventListener('click', () => {
                    this.toggleDeploymentMode('enemy');
                });
            }

            registerCustomBuilding(buildingData) {
                const PROMPT_NAME = prompt("ã‚«ã‚¹ã‚¿ãƒ å»ºé€ ç‰©ã®åå‰", buildingData.name || "Custom Building");
                if (PROMPT_NAME === null) return;
                buildingData.name = PROMPT_NAME;

                // Create registration data
                const newId = 'custom_' + Date.now();

                // Compress blocks to save storage
                let finalData = buildingData;
                if (buildingData.blocks && Array.isArray(buildingData.blocks) && Array.isArray(buildingData.blocks[0])) {
                    const compressed = compressBlocks(buildingData.blocks);
                    finalData = {
                        ...buildingData,
                        blocks: undefined, // remove raw array
                        compressedBlocks: compressed
                    };
                    console.log(`Compressed building data. Original blocks size: ~${JSON.stringify(buildingData.blocks).length}, Compressed: ${compressed.length}`);
                }

                const registeredData = {
                    id: newId,
                    name: buildingData.name,
                    data: finalData
                };

                // Add to Current Map Data
                const map = mapRepository.get(this.currentMapId);
                if (map) {
                    if (!map.customBuildingDefinitions) map.customBuildingDefinitions = [];
                    map.customBuildingDefinitions.push(registeredData);

                    // Sync internal list (Reference copy logic in loadMap ensures they are same, 
                    // but here we ensure this.registeredCustomBuildings refers to the active map list)
                    this.registeredCustomBuildings = map.customBuildingDefinitions;
                } else {
                    // Fallback if no map loaded (should not happen in editor)
                    if (!this.registeredCustomBuildings) this.registeredCustomBuildings = [];
                    this.registeredCustomBuildings.push(registeredData);
                }

                this.generateBuildingButtons();

                const btnContainer = document.getElementById('building-tools');
                if (btnContainer.lastElementChild) btnContainer.lastElementChild.scrollIntoView({ behavior: 'smooth', block: 'center' });
                alert(`ã‚«ã‚¹ã‚¿ãƒ å»ºé€ ç‰©ã€Œ${buildingData.name}ã€ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚`);
            }

            deleteCustomBuilding(id, name) {
                if (!confirm(`ã‚«ã‚¹ã‚¿ãƒ å»ºé€ ç‰©ã€Œ${name}ã€ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆé…ç½®æ¸ˆã¿ã®å»ºç‰©ã¯æ®‹ã‚Šã¾ã™ãŒã€æ–°è¦é…ç½®ã¯ã§ããªããªã‚Šã¾ã™ï¼‰`)) return;

                const map = mapRepository.get(this.currentMapId);
                if (map && map.customBuildingDefinitions) {
                    map.customBuildingDefinitions = map.customBuildingDefinitions.filter(cb => cb.id !== id);
                    this.registeredCustomBuildings = map.customBuildingDefinitions;

                    // Update storage immediately to prevent data loss on refresh
                    mapRepository.saveToStorage();

                    this.generateBuildingButtons();

                    // If selected, deselect
                    if (this.currentBuilding === id) {
                        this.currentBuilding = null;
                        this.setTool('select');
                    }
                }
            }

            // ==========================================
            // Unit Editor Methods
            // ==========================================
            openUnitModal() {
                const modal = document.getElementById('unit-modal');
                modal.classList.add('active');

                // Populate Unit Types
                const typeSelect = document.getElementById('unit-type');
                typeSelect.innerHTML = '';
                Object.keys(UNIT_TYPES).forEach(key => {
                    const type = UNIT_TYPES[key];
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = type.name;
                    typeSelect.appendChild(opt);
                });

                // Reset inputs
                document.getElementById('unit-name').value = '';
                document.querySelector('input[name="unit-role"][value="normal"]').checked = true;
                document.getElementById('unit-count').value = 10;
                document.getElementById('unit-level').value = 99;
                document.getElementById('unit-hp').value = 1000;
            }

            closeUnitModal() {
                document.getElementById('unit-modal').classList.remove('active');
            }

            saveUnitDefinition() {
                const name = document.getElementById('unit-name').value.trim();
                if (!name) {
                    alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                    return;
                }
                const role = document.querySelector('input[name="unit-role"]:checked').value;
                const type = document.getElementById('unit-type').value;
                const count = parseInt(document.getElementById('unit-count').value, 10);
                const level = parseInt(document.getElementById('unit-level').value, 10);
                const hp = parseInt(document.getElementById('unit-hp').value, 10);

                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                if (!map.unitDefinitions) map.unitDefinitions = [];

                const newDef = {
                    id: 'ud_' + Date.now(),
                    name,
                    role,
                    type,
                    count,
                    level,
                    hp
                };

                map.unitDefinitions.push(newDef);
                this.closeUnitModal();
                this.renderUnitList();

                // Select the new unit
                this.selectUnitDef(newDef.id);
            }

            renderUnitList() {
                const list = document.getElementById('unit-list');
                list.innerHTML = '';

                const map = mapRepository.get(this.currentMapId);
                if (!map || !map.unitDefinitions) return;

                map.unitDefinitions.forEach(def => {
                    const el = document.createElement('div');
                    el.className = 'unit-list-item ' + (this.currentUnitDefId === def.id ? 'active' : '');
                    el.innerHTML = `
                        <div class="unit-info">
                            <span class="unit-name">${def.name}</span>
                            <span class="unit-details">${UNIT_TYPES[def.type].marker} ${UNIT_TYPES[def.type].name} x${def.count} Lv${def.level}</span>
                        </div>
                        <span class="unit-delete-btn">Ã—</span>
                    `;
                    el.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('unit-delete-btn')) {
                            this.selectUnitDef(def.id);
                        }
                    });
                    el.querySelector('.unit-delete-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteUnitDef(def.id);
                    });
                    list.appendChild(el);
                });
            }

            toggleDeploymentMode(mode) {
                // åŒã˜ãƒ¢ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ã‚ªãƒ•
                if (this.deploymentMode === mode) {
                    this.deploymentMode = null;
                    this.setTool('select');
                    document.getElementById('btn-set-player-zone').textContent = 'è¨­å®š';
                    document.getElementById('btn-set-enemy-zone').textContent = 'è¨­å®š';
                } else {
                    this.deploymentMode = mode;
                    this.setTool('deployment');
                    // ãƒœã‚¿ãƒ³ã®è¦‹ãŸç›®ã‚’å¤‰æ›´
                    if (mode === 'player') {
                        document.getElementById('btn-set-player-zone').textContent = 'è¨­å®šä¸­...';
                        document.getElementById('btn-set-enemy-zone').textContent = 'è¨­å®š';
                    } else {
                        document.getElementById('btn-set-enemy-zone').textContent = 'è¨­å®šä¸­...';
                        document.getElementById('btn-set-player-zone').textContent = 'è¨­å®š';
                    }
                }
                this.render();
            }

            selectUnitDef(id) {
                this.currentUnitDefId = id;
                this.currentBuilding = null;
                this.currentTerrain = null;
                this.setTool('unit'); // Custom tool state for unit placement
                this.renderUnitList();
            }

            deleteUnitDef(id) {
                if (!confirm('ã“ã®ãƒ¦ãƒ‹ãƒƒãƒˆå®šç¾©ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\né…ç½®æ¸ˆã¿ã®ãƒ¦ãƒ‹ãƒƒãƒˆã‚‚å‰Šé™¤ã•ã‚Œã¾ã™ã€‚')) return;

                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                map.unitDefinitions = map.unitDefinitions.filter(d => d.id !== id);
                // Also remove placed units of this type
                if (map.units) {
                    map.units = map.units.filter(u => u.defId !== id);
                }

                if (this.currentUnitDefId === id) {
                    this.currentUnitDefId = null;
                    this.setTool('select');
                }
                this.renderUnitList();
                this.render();
            }

            createNewMap() {
                const width = parseInt(document.getElementById('map-width').value) || 30;
                const height = parseInt(document.getElementById('map-height').value) || 30;
                // åå‰ã‚’æ˜ç¤ºçš„ã«å…¥åŠ›ã•ã›ã‚‹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã€Œæ–°è¦ãƒãƒƒãƒ—ã€ï¼‰
                const name = prompt('æ–°è¦ãƒãƒƒãƒ—ã®åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'æ–°è¦ãƒãƒƒãƒ—') || 'æ–°è¦ãƒãƒƒãƒ—';

                // å…¥åŠ›æ¬„ã‚‚æ›´æ–°
                document.getElementById('map-name').value = name;

                const map = mapRepository.create({ name, width, height });
                this.currentMapId = map.id;

                // å³åº§ã«ä¿å­˜
                mapRepository.saveToStorage();

                this.resizeCanvas();
                this.render();
                this.updateInfo();
                this.refreshMapList();
                this.update3DPreview();
                this.renderUnitList();
            }

            loadMap(mapId) {
                this.currentMapId = mapId;
                const map = mapRepository.get(mapId);
                if (map) {
                    console.log('[MapEditor] loadMap - mapId:', mapId, 'name:', map.name);
                    console.log('[MapEditor] loadMap - zones:', map.zones);
                    console.log('[MapEditor] loadMap - playerDeploymentZones:', map.playerDeploymentZones);

                    document.getElementById('map-name').value = map.name;
                    document.getElementById('map-width').value = map.terrain.width;
                    document.getElementById('map-height').value = map.terrain.height;

                    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å¾©å…ƒ
                    if (map.textureData) {
                        this.currentTexture = map.textureData;
                    } else {
                        this.currentTexture = null;
                    }

                    // ã‚«ã‚¹ã‚¿ãƒ å»ºé€ ç‰©å®šç¾©ã‚’ãƒ­ãƒ¼ãƒ‰
                    if (map.customBuildingDefinitions) {
                        this.registeredCustomBuildings = map.customBuildingDefinitions;
                    } else {
                        this.registeredCustomBuildings = [];
                    }
                    this.generateBuildingButtons();

                    // é…ç½®ã‚¨ãƒªã‚¢æƒ…å ±ã¯ map.playerDeploymentZones ã‚’ç›´æ¥ä½¿ç”¨
                    // å¿…è¦ã«å¿œã˜ã¦åˆæœŸåŒ–
                    if (!map.playerDeploymentZones) {
                        map.playerDeploymentZones = [];
                        console.log('[MapEditor] loadMap - Initialized empty playerDeploymentZones');
                    }

                    // unitDefinitionsã‚‚ã‚¨ãƒ‡ã‚£ã‚¿å†…ã®å‚ç…§ç”¨ã«å¾©å…ƒ
                    // map.unitDefinitionsã¯ç›´æ¥mapRepositoryå†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¦ã„ã‚‹ãŒã€
                    // æ˜ç¤ºçš„ã«thisçµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
                    if (!map.unitDefinitions) {
                        map.unitDefinitions = [];
                    }

                    this.resizeCanvas();
                    this.render();
                    this.updateInfo();
                    this.update3DPreview();
                    this.renderUnitList();
                }
            }

            saveCurrentMap() {
                console.log('[MapEditor] saveCurrentMap CALLED!');
                if (!this.currentMapId) {
                    console.log('[MapEditor] ERROR: No currentMapId');
                    return;
                }
                const map = mapRepository.get(this.currentMapId);
                const name = document.getElementById('map-name').value;

                console.log('[MapEditor] saveCurrentMap - currentMapId:', this.currentMapId);
                console.log('[MapEditor] saveCurrentMap - playerDeploymentZones:', map.playerDeploymentZones);
                console.log('[MapEditor] saveCurrentMap - existing zones:', map.zones);

                // playerDeploymentZones ã‹ã‚‰ zones.playerDeployment ã®çŸ©å½¢ã‚’è¨ˆç®—
                let playerDeploymentZone = { x: 0, y: 0, width: 10, height: 10 };
                if (map.playerDeploymentZones && map.playerDeploymentZones.length > 0) {
                    const xs = map.playerDeploymentZones.map(z => z.x);
                    const ys = map.playerDeploymentZones.map(z => z.y);
                    const minX = Math.min(...xs);
                    const maxX = Math.max(...xs);
                    const minY = Math.min(...ys);
                    const maxY = Math.max(...ys);
                    playerDeploymentZone = {
                        x: minX,
                        y: minY,
                        width: maxX - minX + 1,
                        height: maxY - minY + 1
                    };
                    console.log('[MapEditor] Calculated playerDeploymentZone from deployment points:', playerDeploymentZone);
                    console.log('[MapEditor] Deployment points count:', map.playerDeploymentZones.length);
                    console.log('[MapEditor] Deployment points:', map.playerDeploymentZones);
                }

                // zones ã‚’ä½œæˆï¼ˆplayerDeployment ã¯è¨ˆç®—ã—ãŸã‚‚ã®ã‚’ä½¿ç”¨ï¼‰
                const currentZones = {
                    playerDeployment: playerDeploymentZone,
                    enemyDeployment: (map.zones && map.zones.enemyDeployment) || { x: 20, y: 20, width: 10, height: 10 },
                    objectives: (map.zones && map.zones.objectives) || []
                };

                console.log('[MapEditor] Saving zones:', currentZones);
                console.log('[MapEditor] Before save - units:', map.units?.length, 'unitDefinitions:', map.unitDefinitions?.length);
                console.log('[MapEditor] unitDefinitions:', JSON.stringify(map.unitDefinitions));

                // Force update with all data
                mapRepository.update(this.currentMapId, {
                    name,
                    terrain: map.terrain,
                    buildings: map.buildings,
                    unitDefinitions: map.unitDefinitions,
                    customBuildingDefinitions: this.registeredCustomBuildings,
                    units: map.units,
                    textureData: this.currentTexture,
                    zones: currentZones,
                    playerDeploymentZones: map.playerDeploymentZones || []
                });

                const success = mapRepository.saveToStorage();

                if (success) {
                    alert('ä¿å­˜ã—ã¾ã—ãŸ');
                } else {
                    alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸï¼');
                }

                this.refreshMapList();
            }

            showMapLoadModal() {
                // ç°¡æ˜“ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’ä½œæˆã—ã¦è¡¨ç¤º
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:10000; display:flex; justify-content:center; align-items:center;';

                const content = document.createElement('div');
                content.style.cssText = 'background:#1a2540; padding:20px; border:2px solid #4a7cff; border-radius:8px; width:500px; max-height:80%; overflow-y:auto; color:white;';

                content.innerHTML = `
                    <h2 style="margin-top:0;">ãƒãƒƒãƒ—èª­ã¿è¾¼ã¿</h2>
                    <div style="margin-bottom:20px;">
                        <h3>ä¿å­˜æ¸ˆã¿ãƒãƒƒãƒ— (LocalStorage)</h3>
                        <div id="modal-local-list" class="map-list" style="max-height:150px; border:1px solid #444; padding:5px;"></div>
                    </div>
                    <div style="margin-bottom:20px;">
                        <h3>ã‚µãƒ³ãƒ—ãƒ«ãƒãƒƒãƒ— (scripts/data/maps)</h3>
                        <div id="modal-sample-list" class="map-list" style="max-height:150px; border:1px solid #444; padding:5px;">
                            <div class="map-item" data-url="./scripts/data/maps/map_sample_tutorial.json">
                                <strong>Tutorial Plain</strong><br>
                                <small>scripts/data/maps/map_sample_tutorial.json</small>
                            </div>
                            <div class="map-item" data-url="./scripts/data/maps/map_sample_castle.json">
                                <strong>Castle</strong><br>
                                <small>scripts/data/maps/map_sample_castle.json</small>
                            </div>
                            <div class="map-item" data-url="./scripts/data/maps/map_sample_mountain.json">
                                <strong>Mountain</strong><br>
                                <small>scripts/data/maps/map_sample_mountain.json</small>
                            </div>
                        </div>
                    </div>
                    <button id="modal-close-btn" class="btn-secondary" style="width:100%;">é–‰ã˜ã‚‹</button>
                    <input type="file" id="modal-file-input" style="display:none" accept=".json">
                    <button id="modal-file-btn" class="btn-primary" style="width:100%; margin-top:10px;">ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€...</button>
                `;

                modal.appendChild(content);
                document.body.appendChild(modal);

                // Local List
                const localList = content.querySelector('#modal-local-list');
                const maps = mapRepository.list();
                if (maps.length === 0) {
                    localList.innerHTML = '<div style="padding:10px; color:#888;">ä¿å­˜ã•ã‚ŒãŸãƒãƒƒãƒ—ã¯ã‚ã‚Šã¾ã›ã‚“</div>';
                } else {
                    maps.forEach(m => {
                        const div = document.createElement('div');
                        div.className = 'map-item';
                        div.innerHTML = `<strong>${m.name}</strong> (ID: ${m.id})<br><small>Size: ${m.terrain?.width}x${m.terrain?.height}</small>`;
                        div.addEventListener('click', () => {
                            this.loadMap(m.id);
                            document.body.removeChild(modal);
                        });
                        localList.appendChild(div);
                    });
                }

                // Sample List
                content.querySelectorAll('#modal-sample-list .map-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const url = item.dataset.url;
                        this.loadSampleMap(url, modal);
                    });
                });

                // File Load
                content.querySelector('#modal-file-btn').addEventListener('click', () => {
                    content.querySelector('#modal-file-input').click();
                });
                content.querySelector('#modal-file-input').addEventListener('change', (e) => {
                    this.importFromJsonFile(e.target.files[0]);
                    document.body.removeChild(modal);
                });

                // Close
                content.querySelector('#modal-close-btn').addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
            }

            async loadSampleMap(url, modal, silent = false) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const json = await response.json();

                    if (json.terrain && json.terrain.width) {
                        let mapId = json.id || 'sample_' + Date.now();

                        // Silent Mode (Auto-load) Logic
                        if (silent) {
                            if (mapRepository.get(mapId)) {
                                console.log(`Sample map ${mapId} already exists. Skipping import.`);
                                return; // Don't overwrite if exists
                            }
                        } else {
                            // Manual load: Duplicate if exists
                            if (mapRepository.get(mapId)) {
                                mapId = mapId + '_' + Date.now();
                                json.id = mapId;
                            }
                        }

                        mapRepository.maps.set(mapId, json);
                        mapRepository.saveToStorage();

                        if (!silent) {
                            this.loadMap(mapId);
                            this.refreshMapList();
                            alert(`ã‚µãƒ³ãƒ—ãƒ«ãƒãƒƒãƒ—ã€Œ${json.name}ã€ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                            if (modal) document.body.removeChild(modal);
                        } else {
                            console.log(`Auto-loaded sample: ${json.name}`);
                            // Silent load doesn't switch map immediately unless we want to?
                            // User requirement: "Startup ... automatically displays in list".
                            // We will refresh list at end of autoLoadSamples.
                        }
                    } else {
                        if (!silent) alert("ç„¡åŠ¹ãªãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã§ã™");
                    }
                } catch (e) {
                    console.error("Failed to load sample map:", e);
                    if (!silent) alert("ã‚µãƒ³ãƒ—ãƒ«ãƒãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
                }
            }

            async autoLoadSamples() {
                const samples = [
                    './scripts/data/maps/map_sample_tutorial.json',
                    './scripts/data/maps/map_sample_castle.json',
                    './scripts/data/maps/map_sample_mountain.json'
                ];
                console.log("Auto-loading samples...");
                // We use Promise.all to load parallel but sequentially is safer for storage sync?
                // Sequential to be safe with localStorage writes if they are not atomic.
                for (const url of samples) {
                    await this.loadSampleMap(url, null, true);
                }
                this.refreshMapList();
            }



            // New: Open Project via File System Access API
            async openProject() {
                if (!window.showOpenFilePicker) {
                    alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ APIã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚å¾“æ¥ã®ã€Œãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã€ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚");
                    return;
                }
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{ description: 'Map JSON Files', accept: { 'application/json': ['.json'] } }],
                        multiple: false
                    });
                    const file = await handle.getFile();
                    const text = await file.text();
                    const data = JSON.parse(text);

                    // Reuse load logic logic or just perform load
                    if (data.terrain && data.terrain.width) {
                        this.fileHandle = handle; // Store handle
                        // Directly load into repository
                        const mapId = data.id;
                        mapRepository.maps.set(mapId, data);
                        mapRepository.saveToStorage();

                        // Use loadMap to restore full state
                        this.loadMap(mapId);

                        this.refreshMapList();
                        console.log("Project loaded with handle:", this.fileHandle.name);
                        alert(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã€Œ${data.name}ã€ã‚’é–‹ãã¾ã—ãŸ`);
                    } else {
                        alert("ç„¡åŠ¹ãªãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã§ã™");
                    }
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error(err);
                        alert("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ: " + err.message);
                    }
                }
            }

            resizeMap() {
                if (!this.currentMapId) return;
                const width = parseInt(document.getElementById('map-width').value) || 30;
                const height = parseInt(document.getElementById('map-height').value) || 30;

                const map = mapRepository.get(this.currentMapId);
                // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¤ã¤ãƒªã‚µã‚¤ã‚º
                const newTerrain = mapRepository.createEmptyTerrain(width, height);
                // ã“ã“ã§ã‚³ãƒ”ãƒ¼å‡¦ç†ã‚’å…¥ã‚Œã‚‹ã“ã¨ã‚‚å¯èƒ½ã ãŒã€ç°¡æ˜“çš„ã«ãƒªã‚»ãƒƒãƒˆã¾ãŸã¯åˆ‡ã‚Šå‡ºã—
                map.terrain = newTerrain;

                this.resizeCanvas();
                this.render();
                this.updateInfo();
                this.update3DPreview();
                this.renderUnitList();
            }

            resizeCanvas() {
                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                this.canvas.width = map.terrain.width * this.cellSize * this.zoom;
                this.canvas.height = map.terrain.height * this.cellSize * this.zoom;
            }

            selectTerrain(terrainId) {
                this.currentTerrain = terrainId;
                this.currentBuilding = null; // å»ºç‰©é¸æŠè§£é™¤
                this.setTool('paint');

                document.querySelectorAll('.terrain-btn').forEach(btn =>
                    btn.classList.toggle('active', btn.dataset.terrain === terrainId));
                document.querySelectorAll('.building-btn').forEach(btn =>
                    btn.classList.remove('active'));
            }

            selectBuilding(buildingKey) {
                this.currentBuilding = buildingKey;
                this.currentTerrain = null; // åœ°å½¢é¸æŠè§£é™¤
                this.currentRotation = 0; // ãƒªã‚»ãƒƒãƒˆ
                this.setTool('building');

                document.querySelectorAll('.building-btn').forEach(btn =>
                    btn.classList.toggle('active', btn.dataset.building === buildingKey));
                document.querySelectorAll('.terrain-btn').forEach(btn =>
                    btn.classList.remove('active'));

                // Deactivate unit list
                this.currentUnitDefId = null;
                this.renderUnitList();
            }

            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('#tool-select, #tool-paint, #tool-fill, #tool-eraser, #tool-raise, #tool-lower, #tool-smooth').forEach(btn => {
                    btn.classList.remove('active');
                });
                const toolBtn = document.getElementById(`tool-${tool}`);
                if (toolBtn) {
                    toolBtn.classList.add('active');
                }

                // If switching away from unit, clear selection
                if (tool !== 'unit') {
                    document.querySelectorAll('.unit-list-item').forEach(el => el.classList.remove('active'));
                    if (tool !== 'unit' && this.currentUnitDefId) {
                        this.currentUnitDefId = null;
                    }
                }
            }

            setZoom(zoom) {
                this.zoom = Math.max(0.5, Math.min(3, zoom));
                this.resizeCanvas();
                this.render();
            }

            getCellFromEvent(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / (this.cellSize * this.zoom));
                const y = Math.floor((e.clientY - rect.top) / (this.cellSize * this.zoom));
                return { x, y };
            }

            onMouseDown(e) {
                // å³ã‚¯ãƒªãƒƒã‚¯ã§å‰Šé™¤ï¼ˆå„ªå…ˆé †ä½: ãƒ¦ãƒ‹ãƒƒãƒˆ â†’ é…ç½®å¯èƒ½åº§æ¨™ â†’ å»ºç‰©ã€1ã‚¯ãƒªãƒƒã‚¯ãšã¤ï¼‰
                if (e.button === 2) {
                    const cell = this.getCellFromEvent(e);
                    let removed = false;

                    const map = mapRepository.get(this.currentMapId);

                    // 1. ãƒ¦ãƒ‹ãƒƒãƒˆå‰Šé™¤
                    if (map && map.units) {
                        const idx = map.units.findIndex(u => u.x === cell.x && u.y === cell.y);
                        if (idx >= 0) {
                            map.units.splice(idx, 1);
                            removed = true;
                        }
                    }

                    // 2. ãƒ¦ãƒ‹ãƒƒãƒˆãŒãªã„å ´åˆã¯é…ç½®å¯èƒ½åº§æ¨™ã‚’å‰Šé™¤
                    if (!removed && map && map.playerDeploymentZones) {
                        const idx = map.playerDeploymentZones.findIndex(z => z.x === cell.x && z.y === cell.y);
                        if (idx >= 0) {
                            map.playerDeploymentZones.splice(idx, 1);
                            removed = true;
                        }
                    }

                    // 3. ãƒ¦ãƒ‹ãƒƒãƒˆã‚‚é…ç½®å¯èƒ½åº§æ¨™ã‚‚ãªã„å ´åˆã¯å»ºé€ ç‰©ã‚’å‰Šé™¤ï¼ˆç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ä»˜ãï¼‰
                    if (!removed) {
                        const building = this.getBuildingAt(cell.x, cell.y);
                        if (building) {
                            if (confirm('å»ºç‰©ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                                this.removeBuildingAt(cell.x, cell.y);
                            }
                        }
                    }

                    this.render();
                    this.update3DPreviewDebounced();
                    return;
                }

                this.isMouseDown = true;
                const cell = this.getCellFromEvent(e);
                this.paintCell(cell.x, cell.y);
                this.lastCell = cell;
            }

            onMouseMove(e) {
                const cell = this.getCellFromEvent(e);
                document.getElementById('coords-display').textContent = `X: ${cell.x}, Y: ${cell.y}`;

                const cellChanged = !this.lastCell || cell.x !== this.lastCell.x || cell.y !== this.lastCell.y;
                this.lastCell = cell;

                if (this.isMouseDown) {
                    if (cellChanged) {
                        if (this.currentTool !== 'building' && this.currentTool !== 'select' && this.currentTool !== 'fill') {
                            this.paintCell(cell.x, cell.y);
                        } else if (this.currentTool === 'building') {
                            this.render(); // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
                        }
                    }
                }
            }

            onWheel(e) {
                if (e.target === this.canvas) {
                    e.preventDefault();
                    // Zoom update provided in original code via delta, keeping minimal prevention here or restore zoom logic if needed.
                    // Assuming setZoom exists.
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    this.setZoom(this.zoom + delta);
                }
            }

            paintCell(x, y) {
                if (!this.currentMapId) return;
                const map = mapRepository.get(this.currentMapId);
                if (!map || x < 0 || y < 0 || x >= map.terrain.width || y >= map.terrain.height) return;

                if (this.currentTool === 'paint') {
                    if (this.currentTerrain) {
                        mapRepository.setTerrain(this.currentMapId, x, y, this.currentTerrain, this.currentHeight);
                        this.render();
                        this.update3DPreviewDebounced();
                    }
                } else if (this.currentTool === 'raise') {
                    const currentH = map.terrain.heightMap[y][x];
                    if (currentH < 10) {
                        map.terrain.heightMap[y][x] = currentH + 1;
                        this.render();
                        this.update3DPreviewDebounced();
                    }
                } else if (this.currentTool === 'lower') {
                    const currentH = map.terrain.heightMap[y][x];
                    if (currentH > 0) {
                        map.terrain.heightMap[y][x] = currentH - 1;
                        this.render();
                        this.update3DPreviewDebounced();
                    }
                } else if (this.currentTool === 'smooth') {
                    let sum = 0;
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < map.terrain.height && nx >= 0 && nx < map.terrain.width) {
                                sum += map.terrain.heightMap[ny][nx];
                                count++;
                            }
                        }
                    }
                    map.terrain.heightMap[y][x] = Math.round(sum / count);
                    this.render();
                    this.update3DPreviewDebounced();

                } else if (this.currentTool === 'eraser') {
                    let removed = false;
                    if (map.units) {
                        const idx = map.units.findIndex(u => u.x === x && u.y === y);
                        if (idx >= 0) {
                            map.units.splice(idx, 1);
                            removed = true;
                        }
                    }
                    if (!removed && map.playerDeploymentZones) {
                        const idx = map.playerDeploymentZones.findIndex(z => z.x === x && z.y === y);
                        if (idx >= 0) {
                            map.playerDeploymentZones.splice(idx, 1);
                            removed = true;
                        }
                    }
                    if (!removed) {
                        const building = this.getBuildingAt(x, y);
                        if (building) {
                            if (confirm('å»ºç‰©ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                                this.removeBuildingAt(x, y);
                            }
                        }
                    }
                    // ä½•ã‚‚å‰Šé™¤ã—ãªã‹ã£ãŸå ´åˆã€åœ°å½¢ã‚’ãƒªã‚»ãƒƒãƒˆ
                    if (!removed) {
                        mapRepository.setTerrain(this.currentMapId, x, y, 'grass', 0);
                    }

                    this.render();
                    this.update3DPreviewDebounced();

                } else if (this.currentTool === 'fill') {
                    this.floodFill(x, y);
                    this.update3DPreview();
                } else if (this.currentTool === 'building') {
                    if (this.currentBuilding) {
                        if (!map.buildings) map.buildings = [];
                        const existingIdx = map.buildings.findIndex(b => b.x === x && b.y === y);
                        if (existingIdx >= 0) {
                            map.buildings.splice(existingIdx, 1);
                        }
                        mapRepository.addBuilding(this.currentMapId, {
                            type: this.currentBuilding,
                            x: x,
                            y: y,
                            rotation: this.currentRotation
                        });
                        this.currentBuilding = null;
                        this.setTool('select');
                        this.render();
                        this.update3DPreview();
                    }
                } else if (this.currentTool === 'unit') {
                    if (this.currentUnitDefId) {
                        if (!map.units) map.units = [];
                        const existingIdx = map.units.findIndex(u => u.x === x && u.y === y);
                        if (existingIdx >= 0) {
                            map.units.splice(existingIdx, 1);
                        }
                        map.units.push({
                            defId: this.currentUnitDefId,
                            x: x,
                            y: y,
                            rotation: 0
                        });
                        this.render();
                    }
                } else if (this.currentTool === 'deployment') {
                    if (!map.playerDeploymentZones) map.playerDeploymentZones = [];
                    if (this.deploymentMode === 'player') {
                        const existingIdx = map.playerDeploymentZones.findIndex(z => z.x === x && z.y === y);
                        if (existingIdx >= 0) {
                            map.playerDeploymentZones.splice(existingIdx, 1);
                        } else {
                            map.playerDeploymentZones.push({ x, y, id: `pz_${Date.now()}` });
                        }
                        this.render();
                        this.update3DPreviewDebounced();
                    }
                }
            }

            removeUnitAt(x, y) {
                const map = mapRepository.get(this.currentMapId);
                if (!map || !map.units) return;
                const idx = map.units.findIndex(u => u.x === x && u.y === y);
                if (idx >= 0) {
                    map.units.splice(idx, 1);
                }
            }

            removeDeploymentZoneAt(x, y) {
                const map = mapRepository.get(this.currentMapId);
                if (!map || !map.playerDeploymentZones) return;
                const idx = map.playerDeploymentZones.findIndex(z => z.x === x && z.y === y);
                if (idx >= 0) {
                    map.playerDeploymentZones.splice(idx, 1);
                }
            }

            removeBuildingAt(x, y) {
                const map = mapRepository.get(this.currentMapId);
                if (!map || !map.buildings) return;
                // Find building covering x,y
                const idx = map.buildings.findIndex(b => {
                    const template = this.getTemplate(b.type);
                    if (!template) return false;
                    const rot = b.rotation || 0;
                    const isRotated = rot % 2 !== 0;
                    const w = isRotated ? template.size.y : template.size.x;
                    const h = isRotated ? template.size.x : template.size.y;
                    return x >= b.x && x < b.x + w && y >= b.y && y < b.y + h;
                });
                if (idx >= 0) {
                    map.buildings.splice(idx, 1);
                }
            }

            getBuildingAt(x, y) {
                if (!this.currentMapId) return null;
                const map = mapRepository.get(this.currentMapId);
                if (!map || !map.buildings) return null;

                return map.buildings.find(b => {
                    const template = this.getTemplate(b.type);
                    if (!template) return false;

                    const rot = b.rotation || 0;
                    const isRotated = rot % 2 !== 0;
                    const w = isRotated ? template.size.y : template.size.x;
                    const h = isRotated ? template.size.x : template.size.y;

                    // ç¯„å›²ãƒã‚§ãƒƒã‚¯
                    const insideX = x >= b.x && x < b.x + w;
                    const insideY = y >= b.y && y < b.y + h;

                    return insideX && insideY;
                });
            }

            // ============================================================
            // Perlinãƒã‚¤ã‚ºå®Ÿè£…
            // ============================================================

            /** ãƒ‘ãƒ¼ãƒŸãƒ¥ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’åˆæœŸåŒ–ï¼ˆå‘¼ã³å‡ºã—æ¯ã«ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰ï¼‰ */
            _initPerlin() {
                const p = Array.from({ length: 256 }, (_, i) => i);
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }
                this._perlinPerm = new Array(512).fill(0).map((_, i) => p[i & 255]);
            }

            _perlinFade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            _perlinLerp(a, b, t) { return a + t * (b - a); }
            _perlinGrad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            /** 2D Perlinãƒã‚¤ã‚ºï¼ˆå€¤åŸŸ: ç´„-1ã€œ1ï¼‰ */
            perlin2D(x, y) {
                const perm = this._perlinPerm;
                const xi = Math.floor(x) & 255;
                const yi = Math.floor(y) & 255;
                const xf = x - Math.floor(x);
                const yf = y - Math.floor(y);
                const u = this._perlinFade(xf);
                const v = this._perlinFade(yf);
                const aa = perm[perm[xi] + yi];
                const ab = perm[perm[xi] + yi + 1];
                const ba = perm[perm[xi + 1] + yi];
                const bb = perm[perm[xi + 1] + yi + 1];
                return this._perlinLerp(
                    this._perlinLerp(this._perlinGrad(aa, xf, yf), this._perlinGrad(ba, xf - 1, yf), u),
                    this._perlinLerp(this._perlinGrad(ab, xf, yf - 1), this._perlinGrad(bb, xf - 1, yf - 1), u),
                    v
                );
            }

            /**
             * fBmï¼ˆãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ï¼‰ãƒã‚¤ã‚ºï¼ˆå€¤åŸŸ: ç´„-1ã€œ1ï¼‰
             * @param {number} x @param {number} y
             * @param {number} octaves ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–æ•°ï¼ˆå¤šã„ã»ã©ç´°ã‹ã„èµ·ä¼ï¼‰
             * @param {number} lacunarity å„ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ã®å‘¨æ³¢æ•°ä¹—æ•°ï¼ˆé€šå¸¸2.0ï¼‰
             * @param {number} gain å„ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ã®æŒ¯å¹…ä¹—æ•°ï¼ˆé€šå¸¸0.5ï¼‰
             */
            fbmNoise(x, y, octaves = 6, lacunarity = 2.0, gain = 0.5) {
                let value = 0, amplitude = 1.0, frequency = 1.0, maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    value += this.perlin2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= gain;
                    frequency *= lacunarity;
                }
                return value / maxValue; // -1ã€œ1ã«æ­£è¦åŒ–
            }

            // ============================================================
            // åœ°å½¢è‡ªå‹•ç”Ÿæˆ
            // ============================================================

            executeTerrainGeneration() {
                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                const preset = document.querySelector('input[name="terrain-preset"]:checked').value;
                const intensity = parseInt(document.getElementById('terrain-intensity').value, 10);
                const baseHeight = parseInt(document.getElementById('terrain-base-height').value, 10);
                const direction = document.getElementById('terrain-direction').value;
                const valleyAxis = document.getElementById('terrain-valley-axis').value;
                const keepBuildings = document.getElementById('terrain-keep-buildings').checked;
                const keepUnits = document.getElementById('terrain-keep-units').checked;

                if (!keepBuildings && map.buildings) map.buildings = [];
                if (!keepUnits && map.units) map.units = [];

                // æ¯å›ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰ã‚’å†åˆæœŸåŒ–ã—ã¦ç•°ãªã‚‹åœ°å½¢ã‚’ç”Ÿæˆ
                this._perlinPerm = null;
                this._initPerlin();

                const W = map.terrain.width;
                const H = map.terrain.height;
                const NS = 4.0; // ãƒã‚¤ã‚ºã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚¹ã‚±ãƒ¼ãƒ«

                // ä¸˜ãƒ—ãƒªã‚»ãƒƒãƒˆç”¨ã®ä¸˜ãƒ‡ãƒ¼ã‚¿ã‚’äº‹å‰ç”Ÿæˆï¼ˆ3ã€œ7å€‹ï¼‰
                const hillData = [];
                if (preset === 'hill') {
                    const numHills = 3 + Math.floor(Math.random() * 5);
                    for (let i = 0; i < numHills; i++) {
                        hillData.push({
                            cx: Math.random() * W,
                            cy: Math.random() * H,
                            rx: W * (0.12 + Math.random() * 0.18),
                            ry: H * (0.12 + Math.random() * 0.18),
                            amp: 0.4 + Math.random() * 0.6
                        });
                    }
                }

                const newHeightMap = Array.from({ length: H }, () => new Array(W).fill(baseHeight));

                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        // æ­£è¦åŒ–åº§æ¨™ï¼ˆ0ã€œ1ï¼‰
                        const nx = x / W;
                        const ny = y / H;
                        let h = baseHeight;

                        if (preset === 'flat') {
                            h = baseHeight;

                        } else if (preset === 'slope') {
                            // å¤§å±€çš„å‚¾æ–œ + Perlinãƒã‚¤ã‚ºã§è‡ªç„¶ãªèµ·ä¼
                            let trend = 0;
                            if (direction === 'n') trend = 1 - ny;
                            else if (direction === 's') trend = ny;
                            else if (direction === 'e') trend = nx;
                            else if (direction === 'w') trend = 1 - nx;
                            const noise = this.fbmNoise(nx * NS, ny * NS, 5, 2.0, 0.5);
                            h = baseHeight + trend * intensity + noise * intensity * 0.35;

                        } else if (preset === 'hill') {
                            // è¤‡æ•°ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ä¸˜ã®é‡ã­åˆã‚ã›
                            let hillH = 0;
                            for (const hd of hillData) {
                                const dx = (x - hd.cx) / hd.rx;
                                const dy = (y - hd.cy) / hd.ry;
                                const d2 = dx * dx + dy * dy;
                                if (d2 < 4.0) hillH += hd.amp * Math.exp(-d2 * 1.5);
                            }
                            // å°è¦æ¨¡ãƒã‚¤ã‚ºã§ãƒ†ã‚¯ã‚¹ãƒãƒ£
                            const noise = this.fbmNoise(nx * NS * 2, ny * NS * 2, 5, 2.0, 0.5);
                            h = baseHeight + Math.min(1, hillH) * intensity + noise * intensity * 0.2;

                        } else if (preset === 'valley') {
                            // Perlinã§è›‡è¡Œã™ã‚‹è°·åº•ã‚’ã‚‚ã¤è°·
                            let dist;
                            if (valleyAxis === 'y') {
                                // å—åŒ—ã«èµ°ã‚‹è°·ï¼ˆæ±è¥¿ãŒé«˜ã„ï¼‰
                                const center = 0.5 + this.perlin2D(ny * 2.5, 17.3) * 0.18;
                                dist = Math.min(1, Math.abs(nx - center) * 2);
                            } else {
                                // æ±è¥¿ã«èµ°ã‚‹è°·ï¼ˆå—åŒ—ãŒé«˜ã„ï¼‰
                                const center = 0.5 + this.perlin2D(21.7, nx * 2.5) * 0.18;
                                dist = Math.min(1, Math.abs(ny - center) * 2);
                            }
                            // smoothstep ã§è°·åº•ã€œå±±è…¹ã‚’æ»‘ã‚‰ã‹ã«
                            const slope = dist * dist * (3 - 2 * dist);
                            const sideNoise = this.fbmNoise(nx * NS, ny * NS, 4, 2.0, 0.5);
                            h = baseHeight + slope * intensity + sideNoise * intensity * 0.25;

                        } else if (preset === 'terrace') {
                            // å¤§å±€çš„å‚¾æ–œã‚’Perlinã§æ³¢æ‰“ãŸã› â†’ é‡å­åŒ–ã§æ®µå·®
                            const trend = (nx + ny) * 0.5;
                            const wave = this.fbmNoise(nx * NS * 0.8, ny * NS * 0.8, 4, 2.0, 0.5);
                            const raw = baseHeight + (trend + wave * 0.45) * intensity;
                            const steps = 3 + Math.floor(intensity / 3); // å¼·åº¦ã§æ®µæ•°ãŒå¢—ãˆã‚‹
                            const stepH = 10.0 / steps;
                            h = Math.floor(raw / stepH) * stepH;

                        } else if (preset === 'random') {
                            // ç´”ç²‹fBmï¼šè‡ªç„¶ãªèµ·ä¼ã®ã‚ã‚‹åœ°å½¢ï¼ˆå¹³é‡ã€œå±±å²³ãŒãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†å¸ƒï¼‰
                            const noise = this.fbmNoise(nx * NS, ny * NS, 6, 2.0, 0.5);
                            h = baseHeight + noise * intensity;
                        }

                        newHeightMap[y][x] = Math.max(0, Math.min(10, Math.round(h)));
                    }
                }

                map.terrain.heightMap = newHeightMap;
                this.render();
                this.update3DPreviewDebounced();
                alert('åœ°å½¢ã‚’ç”Ÿæˆã—ã¾ã—ãŸã€‚');
            }

            floodFill(startX, startY) {
                const map = mapRepository.get(this.currentMapId);
                if (!map || !this.currentTerrain) return;

                const targetType = map.terrain.terrainType[startY][startX];
                if (targetType === this.currentTerrain) return;

                const stack = [[startX, startY]];
                const visited = new Set();
                const processed = [];

                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const key = `${x},${y}`;

                    if (visited.has(key)) continue;
                    if (x < 0 || y < 0 || x >= map.terrain.width || y >= map.terrain.height) continue;
                    if (map.terrain.terrainType[y][x] !== targetType) continue;

                    visited.add(key);
                    processed.push({ x, y });
                    mapRepository.setTerrain(this.currentMapId, x, y, this.currentTerrain, this.currentHeight);

                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }

                this.render();
            }

            render() {
                if (!this.currentMapId) return;
                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                const ctx = this.ctx;
                const cellSize = this.cellSize * this.zoom;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // åœ°å½¢æç”»
                for (let y = 0; y < map.terrain.height; y++) {
                    for (let x = 0; x < map.terrain.width; x++) {
                        const terrainId = map.terrain.terrainType[y][x];
                        const height = map.terrain.heightMap[y][x];
                        const terrain = TERRAIN_TYPES[terrainId.toUpperCase()] || TERRAIN_TYPES.GRASS;

                        // é«˜ã•ã«å¿œã˜ã¦æ˜ã‚‹ã•èª¿æ•´
                        const brightness = 1 + height * 0.05;
                        ctx.fillStyle = this.adjustBrightness(terrain.color, brightness);
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);

                        // é«˜ã•è¡¨ç¤º
                        if (height > 0) {
                            ctx.fillStyle = 'rgba(255,255,255,0.3)';
                            ctx.font = `${8 * this.zoom}px sans-serif`;
                            ctx.fillText(height, x * cellSize + 2, y * cellSize + cellSize - 2);
                        }
                    }
                }

                // å»ºç‰©æç”»
                if (map.buildings) {
                    map.buildings.forEach(b => {
                        const template = this.getTemplate(b.type);
                        if (!template) return;

                        const rot = b.rotation || 0;
                        const isRotated = rot % 2 !== 0;
                        const w = (isRotated ? template.size.y : template.size.x) * cellSize;
                        const h = (isRotated ? template.size.x : template.size.y) * cellSize;

                        const bx = b.x * cellSize;
                        const by = b.y * cellSize;

                        ctx.fillStyle = 'rgba(100, 150, 255, 0.5)';
                        ctx.strokeStyle = 'rgba(200, 220, 255, 0.8)';
                        ctx.lineWidth = 1;

                        ctx.fillRect(bx, by, w, h);
                        ctx.strokeRect(bx, by, w, h);

                        // åå‰ã¨å‘ã
                        ctx.fillStyle = '#fff';
                        ctx.font = `${10 * this.zoom}px sans-serif`;
                        ctx.fillText(template.name, bx + 2, by + 12 * this.zoom);
                        this.drawDirectionArrow(ctx, bx + w / 2, by + h / 2, Math.min(w, h) * 0.4, rot);
                    });
                }

                // ãƒ¦ãƒ‹ãƒƒãƒˆæç”»
                if (map.units && map.unitDefinitions) {
                    map.units.forEach(u => {
                        const def = map.unitDefinitions.find(d => d.id === u.defId);
                        if (!def) return;

                        const unitType = UNIT_TYPES[def.type];
                        if (!unitType) return;

                        const ux = u.x * cellSize;
                        const uy = u.y * cellSize;

                        // Draw Marker
                        ctx.fillStyle = def.role === 'commander' ? 'rgba(255, 50, 50, 0.7)' : 'rgba(50, 100, 255, 0.7)';
                        // Highlight selected unit type
                        if (this.currentTool === 'unit' && this.currentUnitDefId === u.defId) {
                            ctx.fillStyle = 'rgba(100, 255, 100, 0.8)';
                        }

                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;

                        ctx.beginPath();
                        ctx.arc(ux + cellSize / 2, uy + cellSize / 2, cellSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        // Icon/Text
                        ctx.fillStyle = '#fff';
                        ctx.font = `${12 * this.zoom}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(unitType.marker, ux + cellSize / 2, uy + cellSize / 2);

                        // Count text
                        ctx.font = `${8 * this.zoom}px sans-serif`;
                        ctx.fillText(def.count, ux + cellSize / 2, uy + cellSize - 2);

                        ctx.textAlign = 'start'; // Reset
                        ctx.textBaseline = 'alphabetic';
                    });
                }

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…ç½®åº§æ¨™ãƒãƒ¼ã‚«ãƒ¼ã‚’æç”»
                if (map.playerDeploymentZones && map.playerDeploymentZones.length > 0) {
                    map.playerDeploymentZones.forEach(zone => {
                        const zx = zone.x * cellSize + cellSize / 2;
                        const zy = zone.y * cellSize + cellSize / 2;

                        // é’ã„ãƒ€ã‚¤ãƒ¤ãƒãƒ¼ã‚¯
                        ctx.save();
                        ctx.translate(zx, zy);
                        ctx.rotate(Math.PI / 4);
                        ctx.fillStyle = 'rgba(100, 150, 255, 0.6)';
                        ctx.strokeStyle = '#4af';
                        ctx.lineWidth = 2;
                        const size = cellSize * 0.35;
                        ctx.fillRect(-size, -size, size * 2, size * 2);
                        ctx.strokeRect(-size, -size, size * 2, size * 2);
                        ctx.restore();

                        // P ãƒãƒ¼ã‚¯
                        ctx.fillStyle = '#fff';
                        ctx.font = `bold ${10 * this.zoom}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('P', zx, zy);
                    });
                }

                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»ï¼ˆç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ç”¨ã‚´ãƒ¼ã‚¹ãƒˆï¼‰
                if (this.currentTool === 'building' && this.currentBuilding && this.lastCell) {
                    const template = this.getTemplate(this.currentBuilding);
                    if (template) {
                        const rot = this.currentRotation;
                        const isRotated = rot % 2 !== 0;
                        const w = (isRotated ? template.size.y : template.size.x) * cellSize;
                        const h = (isRotated ? template.size.x : template.size.y) * cellSize;
                        const bx = this.lastCell.x * cellSize;
                        const by = this.lastCell.y * cellSize;

                        ctx.fillStyle = 'rgba(100, 255, 100, 0.5)';
                        ctx.fillRect(bx, by, w, h);
                        ctx.strokeStyle = '#afa';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(bx, by, w, h);

                        this.drawDirectionArrow(ctx, bx + w / 2, by + h / 2, Math.min(w, h) * 0.4, rot);
                    }
                }

                // ã‚°ãƒªãƒƒãƒ‰
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= map.terrain.width; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * cellSize, 0);
                    ctx.lineTo(x * cellSize, map.terrain.height * cellSize);
                    ctx.stroke();
                }
                for (let y = 0; y <= map.terrain.height; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * cellSize);
                    ctx.lineTo(map.terrain.width * cellSize, y * cellSize);
                    ctx.stroke();
                }
            }

            drawDirectionArrow(ctx, cx, cy, radius, rotation) {
                ctx.save();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();

                // Rotation: 0=N(-y), 1=E(+x), 2=S(+y), 3=W(-x)
                // ç”»é¢åº§æ¨™ç³»ã¯YãŒä¸‹ãªã®ã§æ³¨æ„
                // 0: N -> Y-
                // 1: E -> X+
                // 2: S -> Y+
                // 3: W -> X-

                const angle = (rotation * 90 - 90) * (Math.PI / 180); // -90 offset for North start

                // çŸ¢å°ã®å…ˆç«¯
                const tipX = cx + Math.cos(angle) * radius;
                const tipY = cy + Math.sin(angle) * radius;

                // å¾Œç«¯
                const backX = cx - Math.cos(angle) * radius * 0.5;
                const backY = cy - Math.sin(angle) * radius * 0.5;

                // ç¾½å·¦
                const wing1X = cx + Math.cos(angle + 2.5) * radius * 0.5;
                const wing1Y = cy + Math.sin(angle + 2.5) * radius * 0.5;

                // ç¾½å³
                const wing2X = cx + Math.cos(angle - 2.5) * radius * 0.5;
                const wing2Y = cy + Math.sin(angle - 2.5) * radius * 0.5;

                ctx.moveTo(backX, backY);
                ctx.lineTo(tipX, tipY);
                ctx.lineTo(wing1X, wing1Y);
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(wing2X, wing2Y);

                ctx.stroke();
                ctx.restore();
            }

            adjustBrightness(hex, factor) {
                const r = Math.min(255, Math.floor(parseInt(hex.slice(1, 3), 16) * factor));
                const g = Math.min(255, Math.floor(parseInt(hex.slice(3, 5), 16) * factor));
                const b = Math.min(255, Math.floor(parseInt(hex.slice(5, 7), 16) * factor));
                return `rgb(${r},${g},${b})`;
            }

            updateInfo() {
                const map = mapRepository.get(this.currentMapId);
                if (!map) return;
                document.getElementById('info-size').textContent = `${map.terrain.width} Ã— ${map.terrain.height}`;
            }

            refreshMapList() {
                const list = document.getElementById('map-list');
                const maps = mapRepository.list();

                list.innerHTML = maps.map(m => `
                    <div class="map-item ${m.id === this.currentMapId ? 'active' : ''}" data-id="${m.id}">
                        <span class="map-name">${m.name}</span>
                        <span class="map-delete-btn" data-id="${m.id}" title="å‰Šé™¤">Ã—</span>
                    </div>
                `).join('');

                list.querySelectorAll('.map-item').forEach(item => {
                    // åå‰éƒ¨åˆ†ã‚¯ãƒªãƒƒã‚¯ã§ãƒ­ãƒ¼ãƒ‰
                    item.addEventListener('click', (e) => {
                        // å‰Šé™¤ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã¯ç™ºç«ã•ã›ãªã„
                        if (!e.target.classList.contains('map-delete-btn')) {
                            this.loadMap(item.dataset.id);
                        }
                    });
                });

                list.querySelectorAll('.map-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation(); // è¦ªã®clickã‚¤ãƒ™ãƒ³ãƒˆã‚’é˜²æ­¢
                        this.deleteMap(btn.dataset.id);
                    });
                });
            }

            deleteMap(mapId) {
                if (!confirm('æœ¬å½“ã«ã“ã®ãƒãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nå‰Šé™¤ã™ã‚‹ã¨å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚')) return;

                if (mapRepository.delete(mapId)) {
                    mapRepository.saveToStorage();

                    // ç¾åœ¨é–‹ã„ã¦ã„ã‚‹ãƒãƒƒãƒ—ã‚’å‰Šé™¤ã—ãŸå ´åˆã®å‡¦ç†
                    if (this.currentMapId === mapId) {
                        this.currentMapId = null;
                        this.refreshMapList();

                        // ãƒªã‚¹ãƒˆãŒæ®‹ã£ã¦ã„ã‚Œã°å…ˆé ­ã‚’é–‹ãã€ãªã‘ã‚Œã°æ–°è¦ä½œæˆ
                        const maps = mapRepository.list();
                        if (maps.length > 0) {
                            this.loadMap(maps[0].id);
                        } else {
                            this.createNewMap();
                        }
                    } else {
                        // åˆ¥ã®ãƒãƒƒãƒ—ã‚’é–‹ã„ã¦ã„ã‚‹å ´åˆã€ãƒªã‚¹ãƒˆæ›´æ–°ã®ã¿
                        this.refreshMapList();
                    }
                }
            }

            async exportToJson(quickSave = false) {
                console.log('[MapEditor] exportToJson CALLED!');
                if (!this.currentMapId) {
                    console.log('[MapEditor] ERROR: No currentMapId');
                    return;
                }

                const map = mapRepository.get(this.currentMapId);
                if (!map) {
                    console.log('[MapEditor] ERROR: No map found for id:', this.currentMapId);
                    return;
                }

                console.log('[MapEditor] exportToJson - unitDefinitions:', JSON.stringify(map.unitDefinitions));

                // playerDeploymentZones ã‹ã‚‰ zones.playerDeployment ã®çŸ©å½¢ã‚’è¨ˆç®—
                let playerDeploymentZone = { x: 0, y: 0, width: 10, height: 10 };
                if (map.playerDeploymentZones && map.playerDeploymentZones.length > 0) {
                    const xs = map.playerDeploymentZones.map(z => z.x);
                    const ys = map.playerDeploymentZones.map(z => z.y);
                    const minX = Math.min(...xs);
                    const maxX = Math.max(...xs);
                    const minY = Math.min(...ys);
                    const maxY = Math.max(...ys);
                    playerDeploymentZone = {
                        x: minX,
                        y: minY,
                        width: maxX - minX + 1,
                        height: maxY - minY + 1
                    };
                    console.log('[MapEditor] Export: Calculated playerDeploymentZone from deployment points:', playerDeploymentZone);
                }

                // zones ã‚’ä½œæˆï¼ˆplayerDeployment ã¯è¨ˆç®—ã—ãŸã‚‚ã®ã‚’ä½¿ç”¨ï¼‰
                const currentZones = {
                    playerDeployment: playerDeploymentZone,
                    enemyDeployment: (map.zones && map.zones.enemyDeployment) || { x: 20, y: 20, width: 10, height: 10 },
                    objectives: (map.zones && map.zones.objectives) || []
                };

                const exportData = {
                    id: map.id,
                    name: document.getElementById('map-id')?.value || map.name,
                    description: map.description,
                    version: map.version,
                    createdAt: map.createdAt,
                    updatedAt: new Date(),
                    metadata: map.metadata,
                    terrain: map.terrain,
                    buildings: map.buildings,
                    zones: currentZones,
                    playerDeploymentZones: map.playerDeploymentZones || [],
                    customBuildingDefinitions: this.registeredCustomBuildings,
                    unitDefinitions: map.unitDefinitions || [],
                    units: map.units || []
                };

                // Update repository with new data
                mapRepository.update(map.id, exportData);
                // CRITICAL: Save to localStorage so data persists after reload
                mapRepository.saveToStorage();

                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });

                // Quick Save Logic
                if (quickSave && this.fileHandle) {
                    try {
                        const writable = await this.fileHandle.createWritable();
                        await writable.write(jsonString);
                        await writable.close();
                        console.log("Quick saved to:", this.fileHandle.name);
                        alert("ä¿å­˜ã—ã¾ã—ãŸ (" + this.fileHandle.name + ")");
                        return;
                    } catch (err) {
                        console.warn("Quick save failed, falling back to picker:", err);
                        // Fall through to picker
                    }
                }

                // File System Access API
                if (window.showSaveFilePicker) {
                    try {
                        const opts = {
                            types: [{
                                description: 'Map JSON File',
                                accept: { 'application/json': ['.json'] },
                            }],
                            suggestedName: `map_${map.id}.json`,
                        };
                        const handle = await window.showSaveFilePicker(opts);
                        const writable = await handle.createWritable();
                        await writable.write(jsonString);
                        await writable.close();

                        this.fileHandle = handle; // Store handle for future quick saves
                        alert("ä¿å­˜ã—ã¾ã—ãŸ");
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error(err);
                            alert("ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚");
                            this.downloadBlob(blob, `map_${map.id}.json`);
                        }
                    }
                } else {
                    // Start download (Fallback)
                    this.downloadBlob(blob, `map_${map.id}.json`);
                }
            }

            downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }

            importFromJsonFile(file) {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const json = e.target.result;
                        const mapData = mapRepository.importFromJson(json);
                        if (mapData) {
                            console.log('Imported Map:', mapData);
                            // Set as current
                            this.currentMapId = mapData.id;
                            // Save to storage immediately
                            mapRepository.saveToStorage();

                            // Use loadMap to restore full state (including registeredCustomBuildings and playerDeploymentZones)
                            this.loadMap(mapData.id);

                            // Load success message
                            alert(`ãƒãƒƒãƒ—ã€Œ${mapData.name}ã€ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                        } else {
                            alert('ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                        }
                    } catch (err) {
                        console.error(err);
                        alert('JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼');
                    }
                };
                reader.readAsText(file);
            }

            // ==========================================
            // ç”»åƒã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
            // ==========================================

            importHeightmap(file) {
                if (!file || !this.currentMapId) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.processHeightmap(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            /**
             * ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§è¨­å®šã—ãŸé–¾å€¤ã«åŸºã¥ãã€é«˜ã•å€¤ã‚’åœ°å½¢ã‚¿ã‚¤ãƒ—ã«å¤‰æ›ã™ã‚‹
             * @param {number} h - é«˜ã• (0-10)
             * @param {Object} thresholds - å„åœ°å½¢ã®ç¯„å›²è¨­å®š
             * @returns {string} åœ°å½¢ã‚¿ã‚¤ãƒ—ID
             */
            heightToTerrainType(h, thresholds) {
                if (h >= thresholds.cliff.min) return 'cliff';
                if (h >= thresholds.mountain.min && h <= thresholds.mountain.max) return 'mountain';
                if (h >= thresholds.forest.min && h <= thresholds.forest.max) return 'forest';
                if (h >= thresholds.grass.min && h <= thresholds.grass.max) return 'grass';
                // è‰åŸç¯„å›²å¤–ï¼ˆé–¾å€¤é–“ã®ã‚®ãƒ£ãƒƒãƒ—ï¼‰ã¯è‰åŸã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                return 'grass';
            }

            processHeightmap(img) {
                const map = mapRepository.get(this.currentMapId);
                const canvas = document.createElement('canvas');
                canvas.width = map.terrain.width;
                canvas.height = map.terrain.height;
                const ctx = canvas.getContext('2d');

                // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‹ã‚‰é–¾å€¤ã‚’èª­ã¿å–ã‚‹
                const thresholds = {
                    grass: { min: parseInt(document.getElementById('hm-grass-min').value, 10), max: parseInt(document.getElementById('hm-grass-max').value, 10) },
                    forest: { min: parseInt(document.getElementById('hm-forest-min').value, 10), max: parseInt(document.getElementById('hm-forest-max').value, 10) },
                    mountain: { min: parseInt(document.getElementById('hm-mountain-min').value, 10), max: parseInt(document.getElementById('hm-mountain-max').value, 10) },
                    cliff: { min: parseInt(document.getElementById('hm-cliff-min').value, 10) }
                };
                const doSmooth = document.getElementById('hm-smooth').checked;

                // ç”»åƒã‚’ãƒãƒƒãƒ—ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦æç”»ï¼ˆãƒªã‚µã‚¤ã‚ºï¼‰
                ctx.drawImage(img, 0, 0, map.terrain.width, map.terrain.height);

                const data = ctx.getImageData(0, 0, map.terrain.width, map.terrain.height).data;

                for (let y = 0; y < map.terrain.height; y++) {
                    for (let x = 0; x < map.terrain.width; x++) {
                        const i = (y * map.terrain.width + x) * 4;
                        // æ˜ã‚‹ã•(0-255)ã‚’é«˜ã•(0-10)ã«å¤‰æ›
                        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const height = Math.floor((brightness / 255) * 10);
                        const clampedHeight = Math.max(0, Math.min(10, height));
                        map.terrain.heightMap[y][x] = clampedHeight;
                        // é«˜ã•é–¾å€¤ã«åŸºã¥ã„ã¦åœ°å½¢ã‚¿ã‚¤ãƒ—ã‚’è‡ªå‹•å‰²ã‚Šå½“ã¦
                        map.terrain.terrainType[y][x] = this.heightToTerrainType(clampedHeight, thresholds);
                    }
                }

                // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å‡¦ç†ï¼ˆæ¥µç«¯ãªå‡¹å‡¸ã‚’æ…£ã‚‰ã™ï¼‰
                if (doSmooth) {
                    const smoothedHeightMap = JSON.parse(JSON.stringify(map.terrain.heightMap));
                    for (let y = 0; y < map.terrain.height; y++) {
                        for (let x = 0; x < map.terrain.width; x++) {
                            let sum = 0;
                            let count = 0;

                            // 3x3 å¹³å‡ãƒ•ã‚£ãƒ«ã‚¿
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < map.terrain.height && nx >= 0 && nx < map.terrain.width) {
                                        sum += map.terrain.heightMap[ny][nx];
                                        count++;
                                    }
                                }
                            }

                            smoothedHeightMap[y][x] = Math.round(sum / count);
                        }
                    }
                    map.terrain.heightMap = smoothedHeightMap;

                    // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®é«˜ã•ã§åœ°å½¢ã‚¿ã‚¤ãƒ—ã‚’å†å‰²ã‚Šå½“ã¦
                    for (let y = 0; y < map.terrain.height; y++) {
                        for (let x = 0; x < map.terrain.width; x++) {
                            map.terrain.terrainType[y][x] = this.heightToTerrainType(map.terrain.heightMap[y][x], thresholds);
                        }
                    }
                }

                this.render();
                this.update3DPreview();
                alert(`ãƒã‚¤ãƒˆãƒãƒƒãƒ—ã‚’é©ç”¨ã—ã¾ã—ãŸã€‚\nè‰åŸ[${thresholds.grass.min}-${thresholds.grass.max}] æ£®[${thresholds.forest.min}-${thresholds.forest.max}] å±±[${thresholds.mountain.min}-${thresholds.mountain.max}] å´–[${thresholds.cliff.min}+]\nåœ°å½¢ã‚¿ã‚¤ãƒ—ã‚‚è‡ªå‹•å‰²ã‚Šå½“ã¦ã—ã¾ã—ãŸã€‚æ°´ãƒã‚¹ã‚¯ã§æ°´åŸŸã‚’è¿½åŠ ã§ãã¾ã™ã€‚`);
            }

            importTerrainImage(file) {
                if (!file || !this.currentMapId) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.processTerrainImage(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            processTerrainImage(img) {
                // ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”»åƒã¨ã—ã¦ä¿å­˜ï¼ˆæœ€å¤§512x512ã«ãƒªã‚µã‚¤ã‚º - LocalStorageå®¹é‡å¯¾ç­–ï¼‰
                const maxTextureSize = 512;
                let texWidth = img.width;
                let texHeight = img.height;

                if (texWidth > maxTextureSize || texHeight > maxTextureSize) {
                    const ratio = Math.min(maxTextureSize / texWidth, maxTextureSize / texHeight);
                    texWidth = Math.floor(texWidth * ratio);
                    texHeight = Math.floor(texHeight * ratio);
                }

                const texCanvas = document.createElement('canvas');
                texCanvas.width = texWidth;
                texCanvas.height = texHeight;
                const texCtx = texCanvas.getContext('2d');
                texCtx.drawImage(img, 0, 0, texWidth, texHeight);
                this.currentTexture = texCanvas.toDataURL('image/jpeg', 0.85); // JPEGå“è³ª0.85ã§ä¿å­˜

                // ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã—ã¦åæ˜ ï¼ˆåœ°å½¢ã‚¿ã‚¤ãƒ—ã¯å¤‰æ›´ã—ãªã„ï¼‰
                const map = mapRepository.get(this.currentMapId);
                map.image = this.currentTexture;
                map.textureData = this.currentTexture; // rendering3d.jså„ªå…ˆèª­ã¿è¾¼ã¿ç”¨

                this.render();
                this.update3DPreview();

                console.log(`[MapEditor] Processed texture size: ${(this.currentTexture.length / 1024).toFixed(1)}KB`);
                alert('åœ°å½¢ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’é©ç”¨ã—ã¾ã—ãŸï¼ˆè¦‹ãŸç›®ã®ã¿ï¼‰ã€‚\nåœ°å½¢ã‚¿ã‚¤ãƒ—ï¼ˆç§»å‹•ã‚³ã‚¹ãƒˆç­‰ï¼‰ã¯å¤‰æ›´ã—ã¾ã›ã‚“ã€‚\nï¼ˆä¿å­˜ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼‰');
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            // ==========================================
            // æ°´ãƒã‚¹ã‚¯èª­ã¿è¾¼ã¿æ©Ÿèƒ½
            // ==========================================

            importWaterMask(file) {
                if (!file || !this.currentMapId) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.processWaterMask(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            processWaterMask(img) {
                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                const canvas = document.createElement('canvas');
                canvas.width = map.terrain.width;
                canvas.height = map.terrain.height;
                const ctx = canvas.getContext('2d');

                // ç”»åƒã‚’ãƒãƒƒãƒ—ã‚µã‚¤ã‚ºã«ãƒªã‚µã‚¤ã‚ºã—ã¦æç”»
                ctx.drawImage(img, 0, 0, map.terrain.width, map.terrain.height);
                const data = ctx.getImageData(0, 0, map.terrain.width, map.terrain.height).data;

                // ã‚°ãƒ¬ãƒ¼å€¤ã®é–¾å€¤
                const riverThreshold = 100;  // 100ä»¥ä¸Š200æœªæº€ â†’ RIVERï¼ˆå·ï¼‰
                const waterThreshold = 200;  // 200ä»¥ä¸Š â†’ WATERï¼ˆæµ·ãƒ»æ¹–ï¼‰

                let waterCount = 0;
                let riverCount = 0;

                for (let y = 0; y < map.terrain.height; y++) {
                    for (let x = 0; x < map.terrain.width; x++) {
                        const i = (y * map.terrain.width + x) * 4;
                        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;

                        if (brightness >= waterThreshold) {
                            // ç™½ â†’ æ°´åŸŸï¼ˆæµ·ãƒ»æ¹–ï¼‰
                            map.terrain.terrainType[y][x] = 'water';
                            map.terrain.heightMap[y][x] = 0; // æ°´é¢ã¯é«˜ã•0
                            waterCount++;
                        } else if (brightness >= riverThreshold) {
                            // ä¸­é–“ã‚°ãƒ¬ãƒ¼ â†’ å·
                            map.terrain.terrainType[y][x] = 'river';
                            map.terrain.heightMap[y][x] = 0;
                            riverCount++;
                        }
                        // é»’ï¼ˆbrightness < riverThresholdï¼‰ã¯å¤‰æ›´ã—ãªã„
                    }
                }

                this.render();
                this.update3DPreview();

                alert(`æ°´ãƒã‚¹ã‚¯ã‚’é©ç”¨ã—ã¾ã—ãŸã€‚\næ°´åŸŸ: ${waterCount}ã‚¿ã‚¤ãƒ«ã€å·: ${riverCount}ã‚¿ã‚¤ãƒ«\nï¼ˆä¿å­˜ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼‰`);
                console.log(`[MapEditor] Water mask applied: WATER=${waterCount}, RIVER=${riverCount}`);
            }

            // ==========================================
            // 3Dãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½ (Three.js)
            // ==========================================

            init3DPreview() {
                try {
                    // Dynamic import for Three.js
                    import('three').then(THREE => {
                        this.THREE = THREE;
                        const canvas = document.getElementById('preview3dCanvas');
                        this.renderer3d = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                        this.scene3d = new THREE.Scene();
                        this.camera3d = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                        this.scene3d.add(ambientLight);
                        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        dirLight.position.set(10, 20, 10);
                        this.scene3d.add(dirLight);

                        // Initial view
                        this.set3DView('perspective');

                        // Animation loop
                        const animate = () => {
                            requestAnimationFrame(animate);
                            // è‡ªå‹•å›è»¢ã‚’å‰Šé™¤
                            this.renderer3d.render(this.scene3d, this.camera3d);
                        };
                        animate();

                        this.update3DPreview();
                    });
                } catch (e) {
                    console.error('Failed to init 3D preview:', e);
                }
            }

            update3DPreview() {
                if (!this.THREE || !this.currentMapId || !this.scene3d) return;

                const map = mapRepository.get(this.currentMapId);
                const THREE = this.THREE;

                // Remove old mesh
                if (this.mesh) {
                    this.scene3d.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }

                // Create heightmap geometry
                const geometry = new THREE.PlaneGeometry(
                    map.terrain.width,
                    map.terrain.height,
                    map.terrain.width - 1,
                    map.terrain.height - 1
                );

                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ç”Ÿæˆã—ã¦è²¼ã‚‹æ–¹å¼
                const texture = new THREE.CanvasTexture(this.canvas);
                texture.magFilter = THREE.NearestFilter;

                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    flatShading: true,
                    roughness: 0.8,
                    metalness: 0.2
                });

                // é ‚ç‚¹ã®é«˜ã•ã‚’è¨­å®š
                const positionAttribute = geometry.attributes.position;
                // PlaneGeometryã®é ‚ç‚¹é †åºã¯å·¦ä¸Šã‹ã‚‰row-majorã§ (x, y) -> (y * (width + 1) + x)
                const width = map.terrain.width;
                const height = map.terrain.height;
                const segmentsW = width - 1;
                const segmentsH = height - 1;

                for (let i = 0; i < positionAttribute.count; i++) {
                    // é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ã‚’é€†ç®—
                    const x = i % (segmentsW + 1);
                    const y = Math.floor(i / (segmentsW + 1));

                    if (x < width && y < height) {
                        const h = map.terrain.heightMap[y][x];
                        if (!isNaN(h)) {
                            positionAttribute.setZ(i, h * 0.5);
                        }
                    }
                }

                positionAttribute.needsUpdate = true;
                geometry.computeVertexNormals();

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2; // å¯ã‹ã›ã‚‹
                this.scene3d.add(this.mesh);

                // å»ºç‰©ã®æç”» (Voxel InstancedMesh)
                if (this.buildingGroup) {
                    this.scene3d.remove(this.buildingGroup);
                    // Dispose logic simplified
                    this.buildingGroup.children.forEach(mesh => {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                    });
                }
                this.buildingGroup = new THREE.Group();
                this.scene3d.add(this.buildingGroup);

                if (map.buildings && map.buildings.length > 0) {
                    // 1. å„ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                    const counts = {};
                    map.buildings.forEach(b => {
                        const template = this.getTemplate(b.type);
                        if (!template || !template.blocks) return;

                        // blocks[z][y][x]
                        for (let z = 0; z < template.size.z; z++) {
                            for (let y = 0; y < template.size.y; y++) {
                                for (let x = 0; x < template.size.x; x++) {
                                    // ç¯„å›²ãƒã‚§ãƒƒã‚¯ (undefinedé¿ã‘)
                                    if (!template.blocks[z] || !template.blocks[z][y]) continue;
                                    const type = template.blocks[z][y][x];
                                    if (type !== BLOCK_TYPES.AIR && type !== undefined) {
                                        counts[type] = (counts[type] || 0) + 1;
                                    }
                                }
                            }
                        }
                    });

                    // 2. InstancedMeshã®ä½œæˆ
                    const meshes = {};
                    const dummy = new THREE.Object3D();
                    const boxGeo = new THREE.BoxGeometry(1, 0.5, 1); // é«˜ã•0.5ã‚¹ã‚±ãƒ¼ãƒ«

                    Object.keys(counts).forEach(type => {
                        const count = counts[type];
                        const color = BLOCK_COLORS[type] || 0xFF00FF;
                        const mat = new THREE.MeshStandardMaterial({ color: color });
                        meshes[type] = new THREE.InstancedMesh(boxGeo, mat, count);
                        meshes[type].count = 0;
                        this.buildingGroup.add(meshes[type]);
                    });

                    // 3. ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹é…ç½®
                    map.buildings.forEach(b => {
                        const template = this.getTemplate(b.type);
                        if (!template || !template.blocks) return;

                        const bx = b.x;
                        const by = b.y;
                        const rot = b.rotation || 0;

                        // åœ°å½¢ã®é«˜ã• (å»ºç‰©åŸºæº–ä½ç½®)
                        let groundH = 0;
                        if (bx >= 0 && bx < map.terrain.width && by >= 0 && by < map.terrain.height) {
                            groundH = map.terrain.heightMap[by][bx] * 0.5;
                        }

                        // å›è»¢å¾Œã®ã‚µã‚¤ã‚º (Loopç”¨)
                        // å…ƒã®ãƒ«ãƒ¼ãƒ—ç¯„å›²ã¯ x:0..Tx, y:0..Ty
                        // åº§æ¨™å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯ã§å¯¾å¿œã™ã‚‹

                        const Tx = template.size.x;
                        const Ty = template.size.y;
                        const Tz = template.size.z;

                        for (let z = 0; z < Tz; z++) {
                            for (let y = 0; y < Ty; y++) {
                                for (let x = 0; x < Tx; x++) {
                                    // ç¯„å›²ãƒã‚§ãƒƒã‚¯
                                    if (!template.blocks[z] || !template.blocks[z][y]) continue;
                                    const type = template.blocks[z][y][x];
                                    if (type === BLOCK_TYPES.AIR || type === undefined) continue;

                                    const mesh = meshes[type];
                                    if (!mesh) continue;

                                    const idx = mesh.count++;

                                    // å›è»¢åº§æ¨™å¤‰æ›
                                    // Local(0,0) -> Rotated(0,0) (Top-Left based)
                                    // Rot 0: x'=x, y'=y
                                    // Rot 1: x'=Ty-1-y, y'=x
                                    // Rot 2: x'=Tx-1-x, y'=Ty-1-y
                                    // Rot 3: x'=y, y'=Tx-1-x

                                    let rx, ry;
                                    switch (rot) {
                                        case 0: rx = x; ry = y; break;
                                        case 1: rx = Ty - 1 - y; ry = x; break;
                                        case 2: rx = Tx - 1 - x; ry = Ty - 1 - y; break;
                                        case 3: rx = y; ry = Tx - 1 - x; break;
                                    }

                                    const wx = (bx + rx) - map.terrain.width / 2 + 0.5;
                                    const wz = (by + ry) - map.terrain.height / 2 + 0.5;
                                    const wy = groundH + (z * 0.5) + 0.25;

                                    dummy.position.set(wx, wy, wz);
                                    dummy.rotation.set(0, 0, 0);
                                    dummy.scale.set(1, 1, 1);
                                    dummy.updateMatrix();
                                    mesh.setMatrixAt(idx, dummy.matrix);
                                }
                            }
                        }
                    });

                    Object.values(meshes).forEach(m => m.instanceMatrix.needsUpdate = true);
                }

                // ãƒ¦ãƒ‹ãƒƒãƒˆã®æç”» (3Dçƒä½“)
                if (this.unitGroup) {
                    this.scene3d.remove(this.unitGroup);
                    this.unitGroup.children.forEach(mesh => {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                    });
                }
                this.unitGroup = new THREE.Group();
                this.scene3d.add(this.unitGroup);

                if (map.units && map.unitDefinitions) {
                    const unitGeo = new THREE.SphereGeometry(0.4, 16, 8);

                    map.units.forEach(u => {
                        const def = map.unitDefinitions.find(d => d.id === u.defId);
                        if (!def) return;

                        const ux = u.x;
                        const uy = u.y;

                        // åœ°å½¢ã®é«˜ã•ã‚’å–å¾—
                        let groundH = 0;
                        if (ux >= 0 && ux < map.terrain.width && uy >= 0 && uy < map.terrain.height) {
                            groundH = map.terrain.heightMap[uy][ux] * 0.5;
                        }

                        // å»ºç‰©ã®é«˜ã•ã‚’è€ƒæ…®ï¼ˆãƒ¦ãƒ‹ãƒƒãƒˆä½ç½®ã§ã®å®Ÿéš›ã®ãƒ–ãƒ­ãƒƒã‚¯é«˜ã•ã‚’è¨ˆç®—ï¼‰
                        if (map.buildings) {
                            for (const b of map.buildings) {
                                const template = this.getTemplate(b.type);
                                if (!template || !template.blocks) continue;

                                const rot = b.rotation || 0;
                                const isRotated = rot % 2 !== 0;
                                const sizeX = isRotated ? template.size.y : template.size.x;
                                const sizeY = isRotated ? template.size.x : template.size.y;

                                if (ux >= b.x && ux < b.x + sizeX &&
                                    uy >= b.y && uy < b.y + sizeY) {
                                    // å»ºç‰©ç¯„å›²å†… - ãã®ä½ç½®ã§ã®æœ€é«˜ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¢ã™
                                    const localX = ux - b.x;
                                    const localY = uy - b.y;

                                    // å›è»¢ã‚’è€ƒæ…®ã—ã¦ãƒ–ãƒ­ãƒƒã‚¯åº§æ¨™ã‚’è¨ˆç®—
                                    let blockX, blockY;
                                    switch (rot) {
                                        case 0: blockX = localX; blockY = localY; break;
                                        case 1: blockX = localY; blockY = template.size.x - 1 - localX; break;
                                        case 2: blockX = template.size.x - 1 - localX; blockY = template.size.y - 1 - localY; break;
                                        case 3: blockX = template.size.y - 1 - localY; blockY = localX; break;
                                        default: blockX = localX; blockY = localY;
                                    }

                                    // ãã®ä½ç½®ã®æœ€é«˜ãƒ–ãƒ­ãƒƒã‚¯ã®Zå€¤ã‚’æ¢ã™
                                    let maxZ = -1;
                                    for (let z = 0; z < template.size.z; z++) {
                                        if (template.blocks[z] &&
                                            template.blocks[z][Math.floor(blockY)] &&
                                            template.blocks[z][Math.floor(blockY)][Math.floor(blockX)] !== undefined &&
                                            template.blocks[z][Math.floor(blockY)][Math.floor(blockX)] !== 0) {
                                            maxZ = z;
                                        }
                                    }

                                    if (maxZ >= 0) {
                                        // æœ€é«˜ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸Šé¢ = (maxZ + 1) * 0.5
                                        groundH += (maxZ + 1) * 0.5;
                                    }
                                    break;
                                }
                            }
                        }

                        // 3Dåº§æ¨™ï¼ˆç›´äº¤åº§æ¨™ç³»ï¼‰
                        const wx = ux - map.terrain.width / 2 + 0.5;
                        const wz = uy - map.terrain.height / 2 + 0.5;
                        const wy = groundH + 0.2; // çƒä½“ãŒæ¥åœ°ã™ã‚‹ã‚ˆã†ã«èª¿æ•´

                        // è‰²: ã‚³ãƒãƒ³ãƒ€ãƒ¼ã¯èµ¤ã€ãã®ä»–ã¯é’
                        const color = def.role === 'commander' ? 0xff3333 : 0x3366ff;
                        const unitMat = new THREE.MeshStandardMaterial({ color: color });
                        const unitMesh = new THREE.Mesh(unitGeo, unitMat);
                        unitMesh.position.set(wx, wy, wz);
                        this.unitGroup.add(unitMesh);
                    });
                }

                this.fitCameraToMesh(map);
            }

            togglePreviewExpand() {
                const container = document.getElementById('preview-3d');
                container.classList.toggle('expanded');
                const isExpanded = container.classList.contains('expanded');

                const btn = document.getElementById('view-expand');
                btn.textContent = isExpanded ? 'ç¸®å°' : 'â¤¢';
                btn.classList.toggle('active', isExpanded);

                requestAnimationFrame(() => {
                    const width = container.clientWidth;
                    const height = container.clientHeight - 30; // header height

                    if (this.renderer3d && this.camera3d) {
                        this.renderer3d.setSize(width, height);
                        this.camera3d.aspect = width / height;
                        this.camera3d.updateProjectionMatrix();
                        this.update3DPreview();
                    }
                });
            }

            update3DPreviewDebounced() {
                if (this.previewTimeout) clearTimeout(this.previewTimeout);
                this.previewTimeout = setTimeout(() => this.update3DPreview(), 500);
            }

            set3DView(type) {
                this.currentView = type;
                if (!this.camera3d || !this.currentMapId) return;

                const map = mapRepository.get(this.currentMapId);
                this.fitCameraToMesh(map);
            }

            rotate3DView() {
                this.viewRotation = (this.viewRotation + 1) % 4;
                this.fitCameraToMesh(mapRepository.get(this.currentMapId));
            }

            fitCameraToMesh(map) {
                if (!map || !this.camera3d) return;

                const size = Math.max(map.terrain.width, map.terrain.height);

                if (this.currentView === 'perspective') {
                    // 90åº¦ã”ã¨ã®è¦–ç‚¹ä½ç½®è¨ˆç®—
                    const angle = this.viewRotation * (Math.PI / 2); // 0, 90, 180, 270 deg
                    const dist = size * 1.2;
                    // ä¸­å¿ƒ(0,0,0)ã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                    const x = Math.sin(angle) * dist + Math.cos(angle) * dist;
                    const z = Math.cos(angle) * dist - Math.sin(angle) * dist;

                    // ã‚ˆã‚Šã€Œå››éš…ã€ã‹ã‚‰ã®è¦–ç‚¹ã«ã™ã‚‹ãŸã‚èª¿æ•´
                    // åŒ—è¥¿(0): (-size, size, -size) -> x+, z+
                    // åŒ—æ±(1): (size, size, -size) -> ??
                    // ã‚·ãƒ³ãƒ—ãƒ«ã«å›è»¢è¡Œåˆ—ã§è€ƒãˆã‚‹
                    // Base pos: (size, size, size) [å—æ±]

                    const baseDist = size;

                    /*
                        Rotation 0 (SE): x+, z+
                        Rotation 1 (SW): x-, z+
                        Rotation 2 (NW): x-, z-
                        Rotation 3 (NE): x+, z-
                    */

                    let camX, camZ;
                    switch (this.viewRotation) {
                        case 0: camX = baseDist; camZ = baseDist; break; // SE
                        case 1: camX = -baseDist; camZ = baseDist; break; // SW
                        case 2: camX = -baseDist; camZ = -baseDist; break; // NW
                        case 3: camX = baseDist; camZ = -baseDist; break; // NE
                    }

                    this.camera3d.position.set(camX, size * 0.8, camZ);
                    this.camera3d.lookAt(0, 0, 0);
                } else {
                    this.camera3d.position.set(0, size * 1.5, 0);
                    this.camera3d.lookAt(0, 0, 0);

                    // çœŸä¸Šè¦–ç‚¹ã®å ´åˆã¯åŒ—ã‚’ä¸Šã«å›ºå®šã€ã‚ã‚‹ã„ã¯ç¾åœ¨ã®å›è»¢ã«åˆã‚ã›ã‚‹ã‹
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã¯ã€Œå››æ–¹å‘ã®è§’ã®æ–œã‚è¦‹ä¸‹ã‚ã—ã€ãªã®ã§ã€Topãƒ“ãƒ¥ãƒ¼ã¯å›ºå®šã§è‰¯ã„
                    this.camera3d.rotation.z = this.viewRotation * (Math.PI / 2);
                }
            }

            save3DPreviewImage() {
                // å°†æ¥çš„ã«ã‚µãƒ ãƒã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜
            }

            removeBuildingAt(x, y) {
                if (!this.currentMapId) return;
                const map = mapRepository.get(this.currentMapId);
                if (!map.buildings) return;

                const initialCount = map.buildings.length;
                map.buildings = map.buildings.filter(b => {
                    const template = this.getTemplate(b.type);
                    if (!template) return true;

                    const rot = b.rotation || 0;
                    const isRotated = rot % 2 !== 0;
                    const w = isRotated ? template.size.y : template.size.x;
                    const h = isRotated ? template.size.x : template.size.y;

                    // ç¯„å›²ãƒã‚§ãƒƒã‚¯ (b.x, b.y) ã‹ã‚‰ (b.x + w, b.y + h)
                    const insideX = x >= b.x && x < b.x + w;
                    const insideY = y >= b.y && y < b.y + h;

                    return !(insideX && insideY); // ç¯„å›²å†…ãªã‚‰é™¤å¤–ï¼ˆå‰Šé™¤ï¼‰
                });

                if (map.buildings.length !== initialCount) {
                    console.log(`Removed ${initialCount - map.buildings.length} buildings at ${x},${y}`);
                    this.render();
                    this.update3DPreview();
                    return true;
                }
                return false;
            }
        }

        // åˆæœŸåŒ–
        const editor = new MapEditor();
    </script>
</body>

</html>