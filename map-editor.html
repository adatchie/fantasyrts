<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Fantasy RTS - „Éû„ÉÉ„Éó„Ç®„Éá„Ç£„Çø</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: #0a0f1a;
            color: #e8f0ff;
            height: 100vh;
            overflow: hidden;
        }

        .editor-layout {
            display: flex;
            height: 100vh;
        }

        /* Â∑¶„Çµ„Ç§„Éâ„Éê„Éº - „ÉÑ„Éº„É´„Éë„É¨„ÉÉ„Éà */
        .tool-sidebar {
            width: 200px;
            background: linear-gradient(180deg, #1a2540, #0f1a30);
            border-right: 2px solid #2a4070;
            display: flex;
            flex-direction: column;
            padding: 12px;
            gap: 12px;
        }

        .sidebar-section {
            background: rgba(30, 45, 70, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.3);
            border-radius: 8px;
            padding: 10px;
        }

        .sidebar-section h3 {
            font-size: 12px;
            color: #8af;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(80, 120, 180, 0.3);
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
        }

        .tool-btn {
            padding: 8px 4px;
            font-size: 11px;
            background: rgba(40, 60, 100, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.4);
            border-radius: 6px;
            color: #ddd;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }

        .tool-btn:hover {
            background: rgba(60, 90, 140, 0.8);
            border-color: #4a7cff;
        }

        .tool-btn.active {
            background: rgba(74, 124, 255, 0.4);
            border-color: #4a7cff;
            color: #fff;
        }

        .terrain-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .terrain-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* „É°„Ç§„É≥„Ç≠„É£„É≥„Éê„Çπ„Ç®„É™„Ç¢ */
        .editor-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-toolbar {
            height: 44px;
            background: #1a2540;
            border-bottom: 1px solid #2a4070;
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 8px;
        }

        .toolbar-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: rgba(40, 60, 100, 0.8);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #ddd;
            cursor: pointer;
            transition: all 0.15s;
        }

        .toolbar-btn:hover {
            background: rgba(60, 90, 140, 0.9);
            border-color: #4a7cff;
        }

        .toolbar-input {
            padding: 4px 8px;
            font-size: 12px;
            background: rgba(20, 30, 50, 0.8);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #e8f0ff;
            width: 120px;
        }

        .toolbar-label {
            font-size: 11px;
            color: #888;
        }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: rgba(80, 120, 180, 0.4);
            margin: 0 8px;
        }

        .canvas-container {
            flex: 1;
            overflow: auto;
            background: #050810;
            position: relative;
        }

        #mapCanvas {
            display: block;
            cursor: crosshair;
        }

        /* Âè≥„Çµ„Ç§„Éâ„Éê„Éº - „Éó„É≠„Éë„ÉÜ„Ç£ */
        .property-sidebar {
            width: 220px;
            background: linear-gradient(180deg, #1a2540, #0f1a30);
            border-left: 2px solid #2a4070;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }

        .prop-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .prop-label {
            color: #888;
        }

        .prop-value {
            color: #8af;
        }

        .prop-input {
            width: 80px;
            padding: 4px 6px;
            font-size: 11px;
            background: rgba(20, 30, 50, 0.8);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #e8f0ff;
        }

        .height-slider {
            width: 100%;
            margin-top: 4px;
        }

        /* „Éû„ÉÉ„Éó„É™„Çπ„Éà */
        .map-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 150px;
            overflow-y: auto;
        }

        .map-item {
            padding: 6px 8px;
            font-size: 11px;
            background: rgba(30, 45, 70, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.3);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .map-item:hover {
            background: rgba(50, 70, 110, 0.8);
        }

        .map-item.active {
            background: rgba(74, 124, 255, 0.3);
            border-color: #4a7cff;
        }

        .map-delete-btn {
            float: right;
            color: #d88;
            font-weight: bold;
            cursor: pointer;
            padding: 0 4px;
            border-radius: 4px;
        }

        .map-delete-btn:hover {
            background: rgba(200, 50, 50, 0.4);
            color: #fcc;
        }

        /* Â∫ßÊ®ôË°®Á§∫ */
        .coords-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-size: 11px;
            color: #8af;
            pointer-events: none;
        }

        /* „Ç∫„Éº„É†„Ç≥„É≥„Éà„É≠„Éº„É´ */
        .zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            font-size: 16px;
            background: rgba(40, 60, 100, 0.9);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #ddd;
            cursor: pointer;
        }

        .zoom-btn:hover {
            background: rgba(60, 90, 140, 0.9);
        }

        /* 3D„Éó„É¨„Éì„É•„Éº */
        .preview-3d {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 280px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(80, 120, 180, 0.5);
            border-radius: 8px;
            overflow: hidden;
        }

        .preview-3d.expanded {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            height: 90vh;
            z-index: 2000;
            background: rgba(10, 15, 25, 0.95);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 2px solid #4a7cff;
        }

        .preview-3d.expanded canvas {
            width: 100% !important;
            height: calc(100% - 30px) !important;
        }

        .preview-3d-header {
            background: rgba(30, 45, 70, 0.9);
            padding: 4px 8px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #preview3dCanvas {
            width: 100%;
            height: calc(100% - 24px);
        }

        /* „Éï„Ç°„Ç§„É´„Ç§„É≥„Éù„Éº„ÉàÁî®„ÅÆÈùûË°®Á§∫input */
        .hidden-input {
            display: none;
        }

        /* „Éì„É•„ÉºÂàá„ÇäÊõø„Åà„Çø„Éñ */
        .view-tabs {
            display: flex;
            gap: 2px;
        }

        .view-tab {
            padding: 2px 8px;
            font-size: 10px;
            background: rgba(40, 60, 100, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.4);
            border-radius: 3px;
            color: #ddd;
            cursor: pointer;
        }

        /* „É¶„Éã„ÉÉ„Éà„É™„Çπ„Éà */
        .unit-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            font-size: 11px;
            background: rgba(30, 45, 70, 0.6);
            border: 1px solid rgba(80, 120, 180, 0.3);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            margin-bottom: 4px;
        }

        .unit-list-item:hover {
            background: rgba(50, 70, 110, 0.8);
        }

        .unit-list-item.active {
            background: rgba(74, 124, 255, 0.3);
            border-color: #4a7cff;
        }

        .unit-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .unit-name {
            font-weight: bold;
            color: #adf;
        }

        .unit-details {
            font-size: 10px;
            color: #88aaff;
        }

        .unit-delete-btn {
            color: #d88;
            font-weight: bold;
            cursor: pointer;
            padding: 2px 6px;
        }

        /* „É¢„Éº„ÉÄ„É´ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 3000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: #1a2540;
            border: 2px solid #4a7cff;
            border-radius: 8px;
            width: 400px;
            padding: 16px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }

        .modal-header {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a4070;
            display: flex;
            justify-content: space-between;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 11px;
            color: #8af;
            margin-bottom: 4px;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 6px;
            background: rgba(10, 15, 25, 0.8);
            border: 1px solid rgba(80, 120, 180, 0.5);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
        }

        .form-row {
            display: flex;
            gap: 8px;
        }

        .btn-primary {
            background: #4a7cff;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-cancel {
            background: #444;
            color: #ddd;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
        }

        .view-tab.active {
            background: rgba(74, 124, 255, 0.4);
            border-color: #4a7cff;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <!-- Error Logger -->
    <div id="error-log"
        style="display:none; position:fixed; top:0; left:0; width:100%; background:rgba(100,0,0,0.8); color:white; padding:10px; z-index:9999; font-family:monospace; pointer-events:none;">
    </div>
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.getElementById('error-log');
            if (div) {
                div.style.display = 'block';
                div.innerHTML += `<div>Error: ${msg} <br> ${url}:${line}:${col}</div>`;
            }
            console.error(msg, error);
            return false;
        };
        window.addEventListener('unhandledrejection', function (event) {
            const div = document.getElementById('error-log');
            if (div) {
                div.style.display = 'block';
                div.innerHTML += `<div>Promise Error: ${event.reason}</div>`;
            }
            console.error(event.reason);
        });
    </script>
    <div class="editor-layout">
        <!-- Â∑¶„Çµ„Ç§„Éâ„Éê„Éº -->
        <div class="tool-sidebar">
            <div class="sidebar-section">
                <h3>üñåÔ∏è Âú∞ÂΩ¢„Éñ„É©„Ç∑</h3>
                <div class="tool-grid" id="terrain-tools">
                    <!-- JS„ÅßÁîüÊàê -->
                </div>
            </div>

            <!-- Âª∫Áâ©„ÉÑ„Éº„É´ -->
            <div class="sidebar-section">
                <h3>üè† Âª∫Áâ©</h3>
                <div class="tool-grid" id="building-tools">
                    <!-- JS„ÅßÁîüÊàê -->
                </div>
                <button class="tool-btn" id="btn-rotate" style="width:100%; margin-top:4px;">‚Üª ÂõûËª¢ (R)</button>

                <div class="sidebar-section">
                    <h3>üìê È´ò„Åï</h3>
                    <div class="prop-row">
                        <span class="prop-label">„É¨„Éô„É´</span>
                        <span class="prop-value" id="height-value">0</span>
                    </div>
                    <input type="range" id="height-slider" class="height-slider" min="0" max="10" value="0">
                </div>



                <div class="sidebar-section">
                    <h3>üîß „ÉÑ„Éº„É´</h3>
                    <div class="tool-grid">
                        <button class="tool-btn" id="tool-select">ÈÅ∏Êäû</button>
                        <button class="tool-btn active" id="tool-paint">„Éö„Ç§„É≥„Éà</button>
                        <button class="tool-btn" id="tool-fill">Â°ó„Çä„Å§„Å∂„Åó</button>
                        <button class="tool-btn" id="tool-eraser">Ê∂à„Åó„Ç¥„É†</button>
                    </div>
                </div>
            </div>

        </div>

        <!-- „É°„Ç§„É≥„Ç®„É™„Ç¢ -->
        <div class="editor-main">
            <div class="editor-toolbar">
                <button class="toolbar-btn" id="btn-new">Êñ∞Ë¶è</button>
                <button class="toolbar-btn" id="btn-save">‰øùÂ≠ò</button>
                <button class="toolbar-btn" id="btn-load">Ë™≠Ëæº</button>
                <div class="toolbar-separator"></div>
                <span class="toolbar-label">„Çµ„Ç§„Ç∫:</span>
                <input type="number" class="toolbar-input" id="map-width" value="30" min="10" max="100"
                    style="width:50px">
                <span class="toolbar-label">√ó</span>
                <input type="number" class="toolbar-input" id="map-height" value="30" min="10" max="100"
                    style="width:50px">
                <button class="toolbar-btn" id="btn-resize">ÈÅ©Áî®</button>
                <div class="toolbar-separator"></div>
                <span class="toolbar-label">„Éû„ÉÉ„ÉóÂêç:</span>
                <input type="text" class="toolbar-input" id="map-name" value="Êñ∞Ë¶è„Éû„ÉÉ„Éó">
                <div class="toolbar-separator"></div>
                <button class="toolbar-btn" id="btn-import-heightmap">üì∑ Ê®ôÈ´òÁîªÂÉèË™≠Ëæº</button>
                <label style="font-size:11px; color:#aaa; margin-left:4px;"><input type="checkbox" id="chk-smooth"
                        checked> Ë£úÊ≠£</label>
                <button class="toolbar-btn" id="btn-import-terrain">üé® Âú∞ÂΩ¢ÁîªÂÉèË™≠Ëæº</button>
                <button class="toolbar-btn" id="btn-export">JSON„Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
                <a href="./building-designer.html" target="_blank" class="toolbar-btn"
                    style="text-decoration:none; display:inline-block; text-align:center;">üî® Âª∫ÈÄ†Áâ©„Ç®„Éá„Ç£„Çø</a>
                <input type="file" id="heightmap-input" class="hidden-input" accept="image/*">
                <input type="file" id="terrain-input" class="hidden-input" accept="image/*">
                <input type="file" id="map-json-input" class="hidden-input" accept=".json">
            </div>

            <div class="canvas-container">
                <canvas id="mapCanvas"></canvas>
                <div class="coords-display" id="coords-display">X: 0, Y: 0</div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-out">‚àí</button>
                    <button class="zoom-btn" id="zoom-in">Ôºã</button>
                </div>
                <!-- 3D„Éó„É¨„Éì„É•„ÉºÁ™ì -->
                <div class="preview-3d" id="preview-3d">
                    <div class="preview-3d-header">
                        <span>üé® 3D„Éó„É¨„Éì„É•„Éº</span>
                        <div class="view-tabs">
                            <button class="view-tab active" id="view-perspective">Êñú„ÇÅ</button>
                            <button class="view-tab" id="view-top">Áúü‰∏ä</button>
                            <button class="view-tab" id="view-rotate" style="margin-left:5px">üîÑ</button>
                            <button class="view-tab" id="view-expand" style="margin-left:5px">‚§¢</button>
                        </div>
                    </div>
                    <canvas id="preview3dCanvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Âè≥„Çµ„Ç§„Éâ„Éê„Éº -->
        <div class="property-sidebar">
            <div class="sidebar-section">
                <h3>üìã „Éû„ÉÉ„ÉóÊÉÖÂ†±</h3>
                <div class="prop-row">
                    <span class="prop-label">„Çµ„Ç§„Ç∫</span>
                    <span class="prop-value" id="info-size">30 √ó 30</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Âª∫ÈÄ†Áâ©</span>
                    <span class="prop-value" id="info-buildings">0</span>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>üìÅ ‰øùÂ≠òÊ∏à„Åø„Éû„ÉÉ„Éó</h3>
                <div class="map-list" id="map-list">
                    <!-- JS„ÅßÁîüÊàê -->
                </div>
            </div>

            <div class="sidebar-section">
                <h3>üéØ ÈÖçÁΩÆ„Ç®„É™„Ç¢</h3>
                <div class="prop-row">
                    <span class="prop-label">„Éó„É¨„Ç§„É§„Éº</span>
                    <button class="toolbar-btn" id="btn-set-player-zone" style="font-size:10px">Ë®≠ÂÆö</button>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Êïµ</span>
                    <button class="toolbar-btn" id="btn-set-enemy-zone" style="font-size:10px">Ë®≠ÂÆö</button>
                </div>
            </div>

            <div class="sidebar-section">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <h3>‚öîÔ∏è Êïµ„É¶„Éã„ÉÉ„ÉàÂÆöÁæ©</h3>
                    <button class="tool-btn" id="btn-add-unit" style="font-size:10px; padding:2px 6px;">ÔºãÊñ∞Ë¶è</button>
                </div>
                <div class="map-list" id="unit-list" style="margin-top:8px;">
                    <!-- JS„ÅßÁîüÊàê -->
                </div>
                <div style="margin-top:8px; font-size:10px; color:#888;">
                    „É™„Çπ„Éà„Åã„ÇâÈÅ∏Êäû„Åó„Å¶„Éö„Ç§„É≥„Éà„ÅßÈÖçÁΩÆ
                </div>
            </div>
        </div>
    </div>

    <!-- „É¶„Éã„ÉÉ„ÉàÂÆöÁæ©„É¢„Éº„ÉÄ„É´ -->
    <div class="modal-overlay" id="unit-modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Êïµ„É¶„Éã„ÉÉ„ÉàÂÆöÁæ©Á∑®ÈõÜ</span>
                <span style="cursor:pointer;" id="btn-close-unit-modal">√ó</span>
            </div>
            <div class="form-group">
                <label class="form-label">ÂêçÂâç (ÂÖ®Ëßí10ÊñáÂ≠ó‰ª•ÂÜÖ)</label>
                <input type="text" class="form-input" id="unit-name" maxlength="10" placeholder="‰æã: „Ç¥„Éñ„É™„É≥ÈÉ®Èöä">
            </div>
            <div class="form-group">
                <label class="form-label">Á´ãÂ†¥</label>
                <div style="display:flex; gap:12px; align-items:center; font-size:12px;">
                    <label><input type="radio" name="unit-role" value="normal" checked> ‰∏ÄËà¨ÂÖµ</label>
                    <label><input type="radio" name="unit-role" value="commander"> ÊåáÊèÆÂÆò</label>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">„É¶„Éã„ÉÉ„ÉàÁ®ÆÈ°û</label>
                <select class="form-select" id="unit-type">
                    <!-- JS„ÅßËá™ÂãïÁîüÊàê -->
                </select>
            </div>
            <div class="form-row">
                <div class="form-group" style="flex:1;">
                    <label class="form-label">„É¶„Éã„ÉÉ„ÉàÊï∞ (1-30)</label>
                    <input type="number" class="form-input" id="unit-count" min="1" max="30" value="10">
                </div>
                <div class="form-group" style="flex:1;">
                    <label class="form-label">„É¨„Éô„É´ (1-99)</label>
                    <input type="number" class="form-input" id="unit-level" min="1" max="99" value="99">
                </div>
                <div class="form-group" style="flex:1;">
                    <label class="form-label">ÊúÄÂ§ßHP</label>
                    <input type="number" class="form-input" id="unit-hp" min="1" max="9999" value="1000">
                </div>
            </div>
            <div style="text-align:right; margin-top:8px;">
                <button class="btn-cancel" id="btn-cancel-unit">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="btn-primary" id="btn-save-unit">‰øùÂ≠ò</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { mapRepository, TERRAIN_TYPES, createSampleMaps } from './scripts/map-repository.js';
        import { BUILDING_TEMPLATES, BLOCK_TYPES, BLOCK_COLORS } from './scripts/building.js';
        import { UNIT_TYPES } from './scripts/constants.js';

        class MapEditor {
            constructor() {
                this.canvas = document.getElementById('mapCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.currentMapId = null;
                this.currentTool = 'paint';
                this.currentTerrain = 'grass';
                this.currentHeight = 0;
                this.currentBuilding = null;

                this.cellSize = 20;
                this.zoom = 1;
                this.offsetX = 0;
                this.offsetY = 0;

                // 3D Preview State
                this.viewRotation = 0; // 0, 1, 2, 3 (x90 deg)
                this.currentRotation = 0; // Building rotation: 0, 1, 2, 3

                this.isMouseDown = false;
                this.lastCell = null;

                this.init();
            }

            init() {
                this.generateTerrainButtons();
                this.generateBuildingButtons();
                this.setupEventListeners();

                // ‰øùÂ≠ò„Åï„Çå„Åü„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
                const hasData = mapRepository.loadFromStorage();

                // „Éá„Éº„Çø„Åå„Å™„ÅÑÂ†¥ÂêàÔºàÂàùÂõûËµ∑Âãï„Å™„Å©Ôºâ„ÅØ„Çµ„É≥„Éó„É´„Éû„ÉÉ„Éó„Çí‰ΩúÊàê
                if (!hasData) {
                    createSampleMaps();
                }

                this.refreshMapList();

                // „Éû„ÉÉ„Éó„É™„Çπ„Éà„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÖàÈ†≠ÔºàÊúÄÂæå„Å´‰øùÂ≠ò„Åï„Çå„Åü„ÇÇ„ÅÆ„Å™„Å©Ôºâ„ÇíÈñã„Åè„ÄÅ„Å™„Åë„Çå„Å∞Êñ∞Ë¶è‰ΩúÊàê
                const maps = mapRepository.list();
                if (maps.length > 0) {
                    // ÊúÄÊñ∞È†Ü„Å´„ÇΩ„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÅØÂÆüË£Ö‰æùÂ≠ò„Å†„Åå„ÄÅ„É™„Çπ„Éà„ÅÆÂÖàÈ†≠„ÇíÈñã„Åè
                    this.loadMap(maps[0].id);
                } else {
                    this.createNewMap();
                }
            }

            generateTerrainButtons() {
                const container = document.getElementById('terrain-tools');
                container.innerHTML = '';

                Object.values(TERRAIN_TYPES).forEach(terrain => {
                    const btn = document.createElement('button');
                    btn.className = 'tool-btn terrain-btn';
                    btn.dataset.terrain = terrain.id;
                    btn.innerHTML = `
                        <div class="terrain-color" style="background:${terrain.color}"></div>
                        <span>${terrain.name}</span>
                    `;
                    btn.addEventListener('click', () => this.selectTerrain(terrain.id));
                    container.appendChild(btn);
                });
            }

            generateBuildingButtons() {
                const container = document.getElementById('building-tools');
                container.innerHTML = '';

                Object.keys(BUILDING_TEMPLATES).forEach(key => {
                    const tmpl = BUILDING_TEMPLATES[key];
                    const btn = document.createElement('button');
                    btn.className = 'tool-btn building-btn';
                    btn.dataset.building = key;
                    btn.innerHTML = `<span>${tmpl.name}</span>`;
                    btn.addEventListener('click', () => this.selectBuilding(key));
                    container.appendChild(btn);
                });
            }

            setupEventListeners() {
                // Canvas events
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.isMouseDown = false);
                this.canvas.addEventListener('mouseleave', () => this.isMouseDown = false);
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    // Âè≥„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ„ÅØ onMouseDown „ÅßË°å„ÅÜ„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ„É°„Éã„É•„ÉºÊäëÂà∂„ÅÆ„Åø
                });

                // Tool buttons
                document.getElementById('tool-paint').addEventListener('click', () => this.setTool('paint'));
                document.getElementById('tool-select').addEventListener('click', () => this.setTool('select'));
                document.getElementById('tool-fill').addEventListener('click', () => this.setTool('fill'));
                document.getElementById('tool-eraser').addEventListener('click', () => this.setTool('eraser'));
                document.getElementById('btn-rotate').addEventListener('click', () => this.rotateBuilding());

                // Key binding
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'r') {
                        this.rotateBuilding();
                    }
                });

                // Height slider
                document.getElementById('height-slider').addEventListener('input', (e) => {
                    this.currentHeight = parseInt(e.target.value);
                    document.getElementById('height-value').textContent = this.currentHeight;
                });

                // Toolbar buttons
                document.getElementById('btn-new').addEventListener('click', () => this.createNewMap());
                document.getElementById('btn-save').addEventListener('click', () => this.saveCurrentMap());
                document.getElementById('btn-resize').addEventListener('click', () => this.resizeMap());
                document.getElementById('btn-export').addEventListener('click', () => this.exportToJson());

                // Heightmap import
                document.getElementById('btn-import-heightmap').addEventListener('click', () => {
                    document.getElementById('heightmap-input').click();
                });
                document.getElementById('heightmap-input').addEventListener('change', (e) => {
                    this.importHeightmap(e.target.files[0]);
                });

                // Terrain image import
                document.getElementById('btn-import-terrain').addEventListener('click', () => {
                    document.getElementById('terrain-input').click();
                });
                document.getElementById('terrain-input').addEventListener('change', (e) => {
                    this.importTerrainImage(e.target.files[0]);
                });

                // 3D Preview view toggle
                document.getElementById('view-perspective').addEventListener('click', () => {
                    this.set3DView('perspective');
                });
                document.getElementById('view-top').addEventListener('click', () => {
                    this.set3DView('top');
                });
                document.getElementById('view-rotate').addEventListener('click', () => {
                    this.rotate3DView();
                });
                document.getElementById('view-expand').addEventListener('click', () => {
                    this.togglePreviewExpand();
                });

                // JSON Import
                document.getElementById('btn-load').addEventListener('click', () => {
                    document.getElementById('map-json-input').click();
                });
                document.getElementById('map-json-input').addEventListener('change', (e) => {
                    this.importFromJson(e.target.files[0]);
                });

                // Zoom
                document.getElementById('zoom-in').addEventListener('click', () => this.setZoom(this.zoom + 0.2));
                document.getElementById('zoom-out').addEventListener('click', () => this.setZoom(this.zoom - 0.2));

                // Initialize 3D preview
                this.init3DPreview();

                // Unit Editor Events
                document.getElementById('btn-add-unit').addEventListener('click', () => this.openUnitModal());
                document.getElementById('btn-close-unit-modal').addEventListener('click', () => this.closeUnitModal());
                document.getElementById('btn-cancel-unit').addEventListener('click', () => this.closeUnitModal());
                document.getElementById('btn-save-unit').addEventListener('click', () => this.saveUnitDefinition());
            }

            // ==========================================
            // Unit Editor Methods
            // ==========================================
            openUnitModal() {
                const modal = document.getElementById('unit-modal');
                modal.classList.add('active');

                // Populate Unit Types
                const typeSelect = document.getElementById('unit-type');
                typeSelect.innerHTML = '';
                Object.keys(UNIT_TYPES).forEach(key => {
                    const type = UNIT_TYPES[key];
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = type.name;
                    typeSelect.appendChild(opt);
                });

                // Reset inputs
                document.getElementById('unit-name').value = '';
                document.querySelector('input[name="unit-role"][value="normal"]').checked = true;
                document.getElementById('unit-count').value = 10;
                document.getElementById('unit-level').value = 99;
                document.getElementById('unit-hp').value = 1000;
            }

            closeUnitModal() {
                document.getElementById('unit-modal').classList.remove('active');
            }

            saveUnitDefinition() {
                const name = document.getElementById('unit-name').value.trim();
                if (!name) {
                    alert('ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                    return;
                }
                const role = document.querySelector('input[name="unit-role"]:checked').value;
                const type = document.getElementById('unit-type').value;
                const count = parseInt(document.getElementById('unit-count').value, 10);
                const level = parseInt(document.getElementById('unit-level').value, 10);
                const hp = parseInt(document.getElementById('unit-hp').value, 10);

                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                if (!map.unitDefinitions) map.unitDefinitions = [];

                const newDef = {
                    id: 'ud_' + Date.now(),
                    name,
                    role,
                    type,
                    count,
                    level,
                    hp
                };

                map.unitDefinitions.push(newDef);
                this.closeUnitModal();
                this.renderUnitList();

                // Select the new unit
                this.selectUnitDef(newDef.id);
            }

            renderUnitList() {
                const list = document.getElementById('unit-list');
                list.innerHTML = '';

                const map = mapRepository.get(this.currentMapId);
                if (!map || !map.unitDefinitions) return;

                map.unitDefinitions.forEach(def => {
                    const el = document.createElement('div');
                    el.className = 'unit-list-item ' + (this.currentUnitDefId === def.id ? 'active' : '');
                    el.innerHTML = `
                        <div class="unit-info">
                            <span class="unit-name">${def.name}</span>
                            <span class="unit-details">${UNIT_TYPES[def.type].marker} ${UNIT_TYPES[def.type].name} x${def.count} Lv${def.level}</span>
                        </div>
                        <span class="unit-delete-btn">√ó</span>
                    `;
                    el.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('unit-delete-btn')) {
                            this.selectUnitDef(def.id);
                        }
                    });
                    el.querySelector('.unit-delete-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteUnitDef(def.id);
                    });
                    list.appendChild(el);
                });
            }

            selectUnitDef(id) {
                this.currentUnitDefId = id;
                this.currentBuilding = null;
                this.currentTerrain = null;
                this.setTool('unit'); // Custom tool state for unit placement
                this.renderUnitList();
            }

            deleteUnitDef(id) {
                if (!confirm('„Åì„ÅÆ„É¶„Éã„ÉÉ„ÉàÂÆöÁæ©„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\nÈÖçÁΩÆÊ∏à„Åø„ÅÆ„É¶„Éã„ÉÉ„Éà„ÇÇÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ')) return;

                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                map.unitDefinitions = map.unitDefinitions.filter(d => d.id !== id);
                // Also remove placed units of this type
                if (map.units) {
                    map.units = map.units.filter(u => u.defId !== id);
                }

                if (this.currentUnitDefId === id) {
                    this.currentUnitDefId = null;
                    this.setTool('select');
                }
                this.renderUnitList();
                this.render();
            }

            createNewMap() {
                const width = parseInt(document.getElementById('map-width').value) || 30;
                const height = parseInt(document.getElementById('map-height').value) || 30;
                // ÂêçÂâç„ÇíÊòéÁ§∫ÁöÑ„Å´ÂÖ•Âäõ„Åï„Åõ„ÇãÔºà„Éá„Éï„Ç©„É´„Éà„ÅØ„ÄåÊñ∞Ë¶è„Éû„ÉÉ„Éó„ÄçÔºâ
                const name = prompt('Êñ∞Ë¶è„Éû„ÉÉ„Éó„ÅÆÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'Êñ∞Ë¶è„Éû„ÉÉ„Éó') || 'Êñ∞Ë¶è„Éû„ÉÉ„Éó';

                // ÂÖ•ÂäõÊ¨Ñ„ÇÇÊõ¥Êñ∞
                document.getElementById('map-name').value = name;

                const map = mapRepository.create({ name, width, height });
                this.currentMapId = map.id;

                // Âç≥Â∫ß„Å´‰øùÂ≠ò
                mapRepository.saveToStorage();

                this.resizeCanvas();
                this.render();
                this.updateInfo();
                this.refreshMapList();
                this.update3DPreview();
                this.renderUnitList();
            }

            loadMap(mapId) {
                this.currentMapId = mapId;
                const map = mapRepository.get(mapId);
                if (map) {
                    document.getElementById('map-name').value = map.name;
                    document.getElementById('map-width').value = map.terrain.width;
                    document.getElementById('map-height').value = map.terrain.height;
                    this.resizeCanvas();
                    this.render();
                    this.updateInfo();
                    this.update3DPreview();
                    this.renderUnitList();
                }
            }

            saveCurrentMap() {
                if (!this.currentMapId) return;
                const map = mapRepository.get(this.currentMapId);
                const name = document.getElementById('map-name').value;

                // Force update with all data
                mapRepository.update(this.currentMapId, {
                    name,
                    terrain: map.terrain,
                    buildings: map.buildings,
                    unitDefinitions: map.unitDefinitions,
                    units: map.units
                });

                const success = mapRepository.saveToStorage();

                if (success) {
                    alert('‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
                } else {
                    alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„ÅüÔºÅ');
                }

                this.refreshMapList();
            }

            resizeMap() {
                if (!this.currentMapId) return;
                const width = parseInt(document.getElementById('map-width').value) || 30;
                const height = parseInt(document.getElementById('map-height').value) || 30;

                const map = mapRepository.get(this.currentMapId);
                // Êó¢Â≠ò„Éá„Éº„Çø„Çí‰øùÊåÅ„Åó„Å§„Å§„É™„Çµ„Ç§„Ç∫
                const newTerrain = mapRepository.createEmptyTerrain(width, height);
                // „Åì„Åì„Åß„Ç≥„Éî„ÉºÂá¶ÁêÜ„ÇíÂÖ•„Çå„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Å†„Åå„ÄÅÁ∞°ÊòìÁöÑ„Å´„É™„Çª„ÉÉ„Éà„Åæ„Åü„ÅØÂàá„ÇäÂá∫„Åó
                map.terrain = newTerrain;

                this.resizeCanvas();
                this.render();
                this.updateInfo();
                this.update3DPreview();
                this.renderUnitList();
            }

            resizeCanvas() {
                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                this.canvas.width = map.terrain.width * this.cellSize * this.zoom;
                this.canvas.height = map.terrain.height * this.cellSize * this.zoom;
            }

            selectTerrain(terrainId) {
                this.currentTerrain = terrainId;
                this.currentBuilding = null; // Âª∫Áâ©ÈÅ∏ÊäûËß£Èô§
                this.setTool('paint');

                document.querySelectorAll('.terrain-btn').forEach(btn =>
                    btn.classList.toggle('active', btn.dataset.terrain === terrainId));
                document.querySelectorAll('.building-btn').forEach(btn =>
                    btn.classList.remove('active'));
            }

            selectBuilding(buildingKey) {
                this.currentBuilding = buildingKey;
                this.currentTerrain = null; // Âú∞ÂΩ¢ÈÅ∏ÊäûËß£Èô§
                this.currentRotation = 0; // „É™„Çª„ÉÉ„Éà
                this.setTool('building');

                document.querySelectorAll('.building-btn').forEach(btn =>
                    btn.classList.toggle('active', btn.dataset.building === buildingKey));
                document.querySelectorAll('.terrain-btn').forEach(btn =>
                    btn.classList.remove('active'));

                // Deactivate unit list
                this.currentUnitDefId = null;
                this.renderUnitList();
            }

            rotateBuilding() {
                if (this.currentTool !== 'building' || !this.currentBuilding) return;
                this.currentRotation = (this.currentRotation + 1) % 4;
                this.render(); // „Éó„É¨„Éì„É•„ÉºÊõ¥Êñ∞
            }

            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('#tool-select, #tool-paint, #tool-fill, #tool-eraser').forEach(btn => {
                    btn.classList.remove('active');
                });
                const toolBtn = document.getElementById(`tool-${tool}`);
                if (toolBtn) {
                    toolBtn.classList.add('active');
                }

                // If switching away from unit, clear selection
                if (tool !== 'unit') {
                    document.querySelectorAll('.unit-list-item').forEach(el => el.classList.remove('active'));
                    if (tool !== 'unit' && this.currentUnitDefId) {
                        this.currentUnitDefId = null;
                    }
                }
            }

            setZoom(zoom) {
                this.zoom = Math.max(0.5, Math.min(3, zoom));
                this.resizeCanvas();
                this.render();
            }

            getCellFromEvent(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / (this.cellSize * this.zoom));
                const y = Math.floor((e.clientY - rect.top) / (this.cellSize * this.zoom));
                return { x, y };
            }

            onMouseDown(e) {
                // Âè≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÂª∫Áâ©ÂâäÈô§
                if (e.button === 2) {
                    const cell = this.getCellFromEvent(e);
                    this.removeBuildingAt(cell.x, cell.y);
                    return;
                }

                this.isMouseDown = true;
                const cell = this.getCellFromEvent(e);
                this.paintCell(cell.x, cell.y);
                this.lastCell = cell;
            }

            onMouseMove(e) {
                const cell = this.getCellFromEvent(e);
                document.getElementById('coords-display').textContent = `X: ${cell.x}, Y: ${cell.y}`;

                const cellChanged = !this.lastCell || cell.x !== this.lastCell.x || cell.y !== this.lastCell.y;
                this.lastCell = cell;

                if (this.isMouseDown) {
                    // Âª∫Áâ©„É¢„Éº„Éâ‰ª•Â§ñ„Å™„Çâ„Éâ„É©„ÉÉ„Ç∞„ÅßÈÄ£Á∂öÊèèÁîª
                    if (cellChanged && this.currentTool !== 'building') {
                        this.paintCell(cell.x, cell.y);
                    }
                } else if (this.currentTool === 'building' && cellChanged) {
                    this.render(); // „Éó„É¨„Éì„É•„ÉºÊõ¥Êñ∞
                }
            }

            onWheel(e) {
                if (e.target === this.canvas) {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    this.setZoom(this.zoom + delta);
                }
            }

            paintCell(x, y) {
                if (!this.currentMapId) return;
                const map = mapRepository.get(this.currentMapId);
                if (!map || x < 0 || y < 0 || x >= map.terrain.width || y >= map.terrain.height) return;

                if (this.currentTool === 'paint') {
                    if (this.currentTerrain) {
                        mapRepository.setTerrain(this.currentMapId, x, y, this.currentTerrain, this.currentHeight);
                        this.render();
                        this.update3DPreviewDebounced();
                    }
                } else if (this.currentTool === 'eraser') {
                    // Âª∫Áâ©„ÇÇÂâäÈô§
                    this.removeBuildingAt(x, y);
                    // „É¶„Éã„ÉÉ„Éà„ÇÇÂâäÈô§
                    this.removeUnitAt(x, y);

                    mapRepository.setTerrain(this.currentMapId, x, y, 'grass', 0);
                    this.render();
                    this.update3DPreviewDebounced();
                } else if (this.currentTool === 'fill') {
                    this.floodFill(x, y);
                    this.update3DPreview();
                } else if (this.currentTool === 'building') {
                    if (this.currentBuilding) {
                        // Êó¢Â≠ò„ÅÆÂª∫Áâ©„ÇíÂâäÈô§ÔºàÂêå„ÅòÂ†¥ÊâÄ„Å´Èáç„Å≠„Å™„ÅÑÔºâ
                        if (!map.buildings) map.buildings = [];
                        // ÂçòÁ¥î„Å™ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                        const existingIdx = map.buildings.findIndex(b => b.x === x && b.y === y);
                        if (existingIdx >= 0) {
                            map.buildings.splice(existingIdx, 1);
                        }

                        mapRepository.addBuilding(this.currentMapId, {
                            type: this.currentBuilding,
                            x: x,
                            y: y,
                            rotation: this.currentRotation
                        });
                        console.log(`Placed building: ${this.currentBuilding} at ${x},${y} rot:${this.currentRotation}`);

                        // ÈÖçÁΩÆÂæå„ÅØÈÅ∏Êäû„É¢„Éº„Éâ„Å´Êàª„ÇãÔºàÈÄ£Á∂öÈÖçÁΩÆÈò≤Ê≠¢Ôºâ
                        this.currentBuilding = null;
                        this.setTool('select');

                        this.render(); // 2D„Ç≠„É£„É≥„Éê„ÇπÊõ¥Êñ∞
                        this.update3DPreview(); // 3DÊõ¥Êñ∞
                    }
                } else if (this.currentTool === 'unit') {
                    if (this.currentUnitDefId) {
                        // Remove existing unit at this location
                        if (!map.units) map.units = [];
                        const existingIdx = map.units.findIndex(u => u.x === x && u.y === y);
                        if (existingIdx >= 0) {
                            map.units.splice(existingIdx, 1);
                        }

                        // Remove building if any (optional)
                        // this.removeBuildingAt(x, y); 

                        map.units.push({
                            defId: this.currentUnitDefId,
                            x: x,
                            y: y,
                            rotation: 0
                        });

                        this.render();
                    }
                }
            }

            removeUnitAt(x, y) {
                const map = mapRepository.get(this.currentMapId);
                if (!map || !map.units) return;
                const idx = map.units.findIndex(u => u.x === x && u.y === y);
                if (idx >= 0) {
                    map.units.splice(idx, 1);
                }
            }

            floodFill(startX, startY) {
                const map = mapRepository.get(this.currentMapId);
                if (!map || !this.currentTerrain) return;

                const targetType = map.terrain.terrainType[startY][startX];
                if (targetType === this.currentTerrain) return;

                const stack = [[startX, startY]];
                const visited = new Set();
                const processed = [];

                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const key = `${x},${y}`;

                    if (visited.has(key)) continue;
                    if (x < 0 || y < 0 || x >= map.terrain.width || y >= map.terrain.height) continue;
                    if (map.terrain.terrainType[y][x] !== targetType) continue;

                    visited.add(key);
                    processed.push({ x, y });
                    mapRepository.setTerrain(this.currentMapId, x, y, this.currentTerrain, this.currentHeight);

                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }

                this.render();
            }

            render() {
                if (!this.currentMapId) return;
                const map = mapRepository.get(this.currentMapId);
                if (!map) return;

                const ctx = this.ctx;
                const cellSize = this.cellSize * this.zoom;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Âú∞ÂΩ¢ÊèèÁîª
                for (let y = 0; y < map.terrain.height; y++) {
                    for (let x = 0; x < map.terrain.width; x++) {
                        const terrainId = map.terrain.terrainType[y][x];
                        const height = map.terrain.heightMap[y][x];
                        const terrain = TERRAIN_TYPES[terrainId.toUpperCase()] || TERRAIN_TYPES.GRASS;

                        // È´ò„Åï„Å´Âøú„Åò„Å¶Êòé„Çã„ÅïË™øÊï¥
                        const brightness = 1 + height * 0.05;
                        ctx.fillStyle = this.adjustBrightness(terrain.color, brightness);
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);

                        // È´ò„ÅïË°®Á§∫
                        if (height > 0) {
                            ctx.fillStyle = 'rgba(255,255,255,0.3)';
                            ctx.font = `${8 * this.zoom}px sans-serif`;
                            ctx.fillText(height, x * cellSize + 2, y * cellSize + cellSize - 2);
                        }
                    }
                }

                // Âª∫Áâ©ÊèèÁîª
                if (map.buildings) {
                    map.buildings.forEach(b => {
                        const template = BUILDING_TEMPLATES[b.type];
                        if (!template) return;

                        const rot = b.rotation || 0;
                        const isRotated = rot % 2 !== 0;
                        const w = (isRotated ? template.size.y : template.size.x) * cellSize;
                        const h = (isRotated ? template.size.x : template.size.y) * cellSize;

                        const bx = b.x * cellSize;
                        const by = b.y * cellSize;

                        ctx.fillStyle = 'rgba(100, 150, 255, 0.5)';
                        ctx.strokeStyle = 'rgba(200, 220, 255, 0.8)';
                        ctx.lineWidth = 1;

                        ctx.fillRect(bx, by, w, h);
                        ctx.strokeRect(bx, by, w, h);

                        // ÂêçÂâç„Å®Âêë„Åç
                        ctx.fillStyle = '#fff';
                        ctx.font = `${10 * this.zoom}px sans-serif`;
                        ctx.fillText(template.name, bx + 2, by + 12 * this.zoom);
                        this.drawDirectionArrow(ctx, bx + w / 2, by + h / 2, Math.min(w, h) * 0.4, rot);
                    });
                }

                // „É¶„Éã„ÉÉ„ÉàÊèèÁîª
                if (map.units && map.unitDefinitions) {
                    map.units.forEach(u => {
                        const def = map.unitDefinitions.find(d => d.id === u.defId);
                        if (!def) return;

                        const unitType = UNIT_TYPES[def.type];
                        if (!unitType) return;

                        const ux = u.x * cellSize;
                        const uy = u.y * cellSize;

                        // Draw Marker
                        ctx.fillStyle = def.role === 'commander' ? 'rgba(255, 50, 50, 0.7)' : 'rgba(50, 100, 255, 0.7)';
                        // Highlight selected unit type
                        if (this.currentTool === 'unit' && this.currentUnitDefId === u.defId) {
                            ctx.fillStyle = 'rgba(100, 255, 100, 0.8)';
                        }

                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;

                        ctx.beginPath();
                        ctx.arc(ux + cellSize / 2, uy + cellSize / 2, cellSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        // Icon/Text
                        ctx.fillStyle = '#fff';
                        ctx.font = `${12 * this.zoom}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(unitType.marker, ux + cellSize / 2, uy + cellSize / 2);

                        // Count text
                        ctx.font = `${8 * this.zoom}px sans-serif`;
                        ctx.fillText(def.count, ux + cellSize / 2, uy + cellSize - 2);

                        ctx.textAlign = 'start'; // Reset
                        ctx.textBaseline = 'alphabetic';
                    });
                }

                // „Éó„É¨„Éì„É•„ÉºÊèèÁîªÔºàÁèæÂú®„ÅÆ„Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆÁî®„Ç¥„Éº„Çπ„ÉàÔºâ
                if (this.currentTool === 'building' && this.currentBuilding && this.lastCell) {
                    const template = BUILDING_TEMPLATES[this.currentBuilding];
                    if (template) {
                        const rot = this.currentRotation;
                        const isRotated = rot % 2 !== 0;
                        const w = (isRotated ? template.size.y : template.size.x) * cellSize;
                        const h = (isRotated ? template.size.x : template.size.y) * cellSize;
                        const bx = this.lastCell.x * cellSize;
                        const by = this.lastCell.y * cellSize;

                        ctx.fillStyle = 'rgba(100, 255, 100, 0.5)';
                        ctx.fillRect(bx, by, w, h);
                        ctx.strokeStyle = '#afa';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(bx, by, w, h);

                        this.drawDirectionArrow(ctx, bx + w / 2, by + h / 2, Math.min(w, h) * 0.4, rot);
                    }
                }

                // „Ç∞„É™„ÉÉ„Éâ
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= map.terrain.width; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * cellSize, 0);
                    ctx.lineTo(x * cellSize, map.terrain.height * cellSize);
                    ctx.stroke();
                }
                for (let y = 0; y <= map.terrain.height; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * cellSize);
                    ctx.lineTo(map.terrain.width * cellSize, y * cellSize);
                    ctx.stroke();
                }
            }

            drawDirectionArrow(ctx, cx, cy, radius, rotation) {
                ctx.save();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();

                // Rotation: 0=N(-y), 1=E(+x), 2=S(+y), 3=W(-x)
                // ÁîªÈù¢Â∫ßÊ®ôÁ≥ª„ÅØY„Åå‰∏ã„Å™„ÅÆ„ÅßÊ≥®ÊÑè
                // 0: N -> Y-
                // 1: E -> X+
                // 2: S -> Y+
                // 3: W -> X-

                const angle = (rotation * 90 - 90) * (Math.PI / 180); // -90 offset for North start

                // Áü¢Âç∞„ÅÆÂÖàÁ´Ø
                const tipX = cx + Math.cos(angle) * radius;
                const tipY = cy + Math.sin(angle) * radius;

                // ÂæåÁ´Ø
                const backX = cx - Math.cos(angle) * radius * 0.5;
                const backY = cy - Math.sin(angle) * radius * 0.5;

                // ÁæΩÂ∑¶
                const wing1X = cx + Math.cos(angle + 2.5) * radius * 0.5;
                const wing1Y = cy + Math.sin(angle + 2.5) * radius * 0.5;

                // ÁæΩÂè≥
                const wing2X = cx + Math.cos(angle - 2.5) * radius * 0.5;
                const wing2Y = cy + Math.sin(angle - 2.5) * radius * 0.5;

                ctx.moveTo(backX, backY);
                ctx.lineTo(tipX, tipY);
                ctx.lineTo(wing1X, wing1Y);
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(wing2X, wing2Y);

                ctx.stroke();
                ctx.restore();
            }

            adjustBrightness(hex, factor) {
                const r = Math.min(255, Math.floor(parseInt(hex.slice(1, 3), 16) * factor));
                const g = Math.min(255, Math.floor(parseInt(hex.slice(3, 5), 16) * factor));
                const b = Math.min(255, Math.floor(parseInt(hex.slice(5, 7), 16) * factor));
                return `rgb(${r},${g},${b})`;
            }

            updateInfo() {
                const map = mapRepository.get(this.currentMapId);
                if (!map) return;
                document.getElementById('info-size').textContent = `${map.terrain.width} √ó ${map.terrain.height}`;
            }

            refreshMapList() {
                const list = document.getElementById('map-list');
                const maps = mapRepository.list();

                list.innerHTML = maps.map(m => `
                    <div class="map-item ${m.id === this.currentMapId ? 'active' : ''}" data-id="${m.id}">
                        <span class="map-name">${m.name}</span>
                        <span class="map-delete-btn" data-id="${m.id}" title="ÂâäÈô§">√ó</span>
                    </div>
                `).join('');

                list.querySelectorAll('.map-item').forEach(item => {
                    // ÂêçÂâçÈÉ®ÂàÜ„ÇØ„É™„ÉÉ„ÇØ„Åß„É≠„Éº„Éâ
                    item.addEventListener('click', (e) => {
                        // ÂâäÈô§„Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅØÁô∫ÁÅ´„Åï„Åõ„Å™„ÅÑ
                        if (!e.target.classList.contains('map-delete-btn')) {
                            this.loadMap(item.dataset.id);
                        }
                    });
                });

                list.querySelectorAll('.map-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Ë¶™„ÅÆclick„Ç§„Éô„É≥„Éà„ÇíÈò≤Ê≠¢
                        this.deleteMap(btn.dataset.id);
                    });
                });
            }

            deleteMap(mapId) {
                if (!confirm('Êú¨ÂΩì„Å´„Åì„ÅÆ„Éû„ÉÉ„Éó„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\nÂâäÈô§„Åô„Çã„Å®ÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ')) return;

                if (mapRepository.delete(mapId)) {
                    mapRepository.saveToStorage();

                    // ÁèæÂú®Èñã„ÅÑ„Å¶„ÅÑ„Çã„Éû„ÉÉ„Éó„ÇíÂâäÈô§„Åó„ÅüÂ†¥Âêà„ÅÆÂá¶ÁêÜ
                    if (this.currentMapId === mapId) {
                        this.currentMapId = null;
                        this.refreshMapList();

                        // „É™„Çπ„Éà„ÅåÊÆã„Å£„Å¶„ÅÑ„Çå„Å∞ÂÖàÈ†≠„ÇíÈñã„Åè„ÄÅ„Å™„Åë„Çå„Å∞Êñ∞Ë¶è‰ΩúÊàê
                        const maps = mapRepository.list();
                        if (maps.length > 0) {
                            this.loadMap(maps[0].id);
                        } else {
                            this.createNewMap();
                        }
                    } else {
                        // Âà•„ÅÆ„Éû„ÉÉ„Éó„ÇíÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„É™„Çπ„ÉàÊõ¥Êñ∞„ÅÆ„Åø
                        this.refreshMapList();
                    }
                }
            }

            exportToJson() {
                const json = mapRepository.exportToJson(this.currentMapId);
                if (!json) return;

                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `map_${this.currentMapId}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            // ==========================================
            // ÁîªÂÉè„Ç§„É≥„Éù„Éº„ÉàÊ©üËÉΩ
            // ==========================================

            importHeightmap(file) {
                if (!file || !this.currentMapId) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.processHeightmap(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            processHeightmap(img) {
                const map = mapRepository.get(this.currentMapId);
                const canvas = document.createElement('canvas');
                canvas.width = map.terrain.width;
                canvas.height = map.terrain.height;
                const ctx = canvas.getContext('2d');

                // ÁîªÂÉè„Çí„Éû„ÉÉ„Éó„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶ÊèèÁîªÔºà„É™„Çµ„Ç§„Ç∫Ôºâ
                ctx.drawImage(img, 0, 0, map.terrain.width, map.terrain.height);

                const data = ctx.getImageData(0, 0, map.terrain.width, map.terrain.height).data;

                for (let y = 0; y < map.terrain.height; y++) {
                    for (let x = 0; x < map.terrain.width; x++) {
                        const i = (y * map.terrain.width + x) * 4;
                        // Êòé„Çã„Åï(0-255)„ÇíÈ´ò„Åï(0-5)„Å´Â§âÊèõÔºà„Å™„Å†„Çâ„Åã„Å´„Åô„Çã„Åü„ÇÅÊúÄÂ§ßÂÄ§„ÇíÊäëÂà∂Ôºâ
                        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const height = Math.floor((brightness / 255) * 5); // 10 -> 5
                        map.terrain.heightMap[y][x] = height;
                    }
                }

                // „Çπ„É†„Éº„Ç∏„É≥„Ç∞Âá¶ÁêÜÔºàÊ•µÁ´Ø„Å™ÂáπÂá∏„ÇíÊÖ£„Çâ„ÅôÔºâ
                if (document.getElementById('chk-smooth').checked) {
                    const smoothedMap = JSON.parse(JSON.stringify(map.terrain.heightMap));
                    for (let y = 0; y < map.terrain.height; y++) {
                        for (let x = 0; x < map.terrain.width; x++) {
                            let sum = 0;
                            let count = 0;

                            // 3x3 Âπ≥Âùá„Éï„Ç£„É´„Çø
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < map.terrain.height && nx >= 0 && nx < map.terrain.width) {
                                        sum += map.terrain.heightMap[ny][nx];
                                        count++;
                                    }
                                }
                            }

                            // ÂõõÊç®‰∫îÂÖ•„Åó„Å¶Êï¥Êï∞„Å´Êàª„Åô
                            smoothedMap[y][x] = Math.round(sum / count);
                        }
                    }
                    map.terrain.heightMap = smoothedMap;
                }

                this.render();
                this.update3DPreview();
                alert('„Éè„Ç§„Éà„Éû„ÉÉ„Éó„ÇíÈÅ©Áî®„Åó„Åæ„Åó„ÅüÔºàÊªë„Çâ„ÅãË£úÊ≠£Ê∏à„ÅøÔºâ');
            }

            importTerrainImage(file) {
                if (!file || !this.currentMapId) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.processTerrainImage(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            processTerrainImage(img) {
                const map = mapRepository.get(this.currentMapId);
                const canvas = document.createElement('canvas');
                canvas.width = map.terrain.width;
                canvas.height = map.terrain.height;
                const ctx = canvas.getContext('2d');

                ctx.drawImage(img, 0, 0, map.terrain.width, map.terrain.height);
                const data = ctx.getImageData(0, 0, map.terrain.width, map.terrain.height).data;

                // RGBÂÄ§„Åã„ÇâÊúÄ„ÇÇËøë„ÅÑÂú∞ÂΩ¢„Çø„Ç§„Éó„ÇíÊé¢„Åô
                const terrainColors = Object.values(TERRAIN_TYPES).map(t => ({
                    id: t.id,
                    rgb: this.hexToRgb(t.color)
                }));

                for (let y = 0; y < map.terrain.height; y++) {
                    for (let x = 0; x < map.terrain.width; x++) {
                        const i = (y * map.terrain.width + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];

                        let minDist = Infinity;
                        let bestTerrain = 'grass';

                        terrainColors.forEach(tc => {
                            const dist = Math.sqrt(
                                Math.pow(r - tc.rgb.r, 2) +
                                Math.pow(g - tc.rgb.g, 2) +
                                Math.pow(b - tc.rgb.b, 2)
                            );
                            if (dist < minDist) {
                                minDist = dist;
                                bestTerrain = tc.id;
                            }
                        });

                        map.terrain.terrainType[y][x] = bestTerrain;
                    }
                }

                this.render();
                this.update3DPreview();

                // ÁîªÂÉè„ÇíÂúßÁ∏Æ„Åó„Å¶‰øùÂ≠òÔºà512x512„Å´Á∏ÆÂ∞è„Åó„Å¶JPEGÈ´òÂìÅË≥™ÂúßÁ∏ÆÔºâ
                const compressCanvas = document.createElement('canvas');
                const compressSize = 512; // ÂúßÁ∏ÆÂæå„ÅÆ„Çµ„Ç§„Ç∫ÔºàÂìÅË≥™ÈáçË¶ñÔºâ
                compressCanvas.width = compressSize;
                compressCanvas.height = compressSize;
                const compressCtx = compressCanvas.getContext('2d');
                compressCtx.drawImage(img, 0, 0, compressSize, compressSize);

                // JPEGÂΩ¢Âºè„ÅßÂìÅË≥™0.85„ÅßÂúßÁ∏ÆÔºàÁ¥Ñ80-150KBÁ®ãÂ∫¶Ôºâ
                map.image = compressCanvas.toDataURL('image/jpeg', 0.85);
                console.log(`[MapEditor] Compressed image size: ${(map.image.length / 1024).toFixed(1)}KB`);

                alert('Âú∞ÂΩ¢„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíËß£Êûê„Åó„Å¶ÈÅ©Áî®„Åó„Åæ„Åó„Åü„ÄÇ\nÔºà‰øùÂ≠ò„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ');
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            // ==========================================
            // 3D„Éó„É¨„Éì„É•„ÉºÊ©üËÉΩ (Three.js)
            // ==========================================

            init3DPreview() {
                try {
                    // Dynamic import for Three.js
                    import('three').then(THREE => {
                        this.THREE = THREE;
                        const canvas = document.getElementById('preview3dCanvas');
                        this.renderer3d = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                        this.scene3d = new THREE.Scene();
                        this.camera3d = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                        this.scene3d.add(ambientLight);
                        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        dirLight.position.set(10, 20, 10);
                        this.scene3d.add(dirLight);

                        // Initial view
                        this.set3DView('perspective');

                        // Animation loop
                        const animate = () => {
                            requestAnimationFrame(animate);
                            // Ëá™ÂãïÂõûËª¢„ÇíÂâäÈô§
                            this.renderer3d.render(this.scene3d, this.camera3d);
                        };
                        animate();

                        this.update3DPreview();
                    });
                } catch (e) {
                    console.error('Failed to init 3D preview:', e);
                }
            }

            update3DPreview() {
                if (!this.THREE || !this.currentMapId || !this.scene3d) return;

                const map = mapRepository.get(this.currentMapId);
                const THREE = this.THREE;

                // Remove old mesh
                if (this.mesh) {
                    this.scene3d.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }

                // Create heightmap geometry
                const geometry = new THREE.PlaneGeometry(
                    map.terrain.width,
                    map.terrain.height,
                    map.terrain.width - 1,
                    map.terrain.height - 1
                );

                // Apply height
                const positionAttribute = geometry.attributes.position;
                const colors = [];
                const color = new THREE.Color();

                for (let y = 0; y < map.terrain.height; y++) {
                    for (let x = 0; x < map.terrain.width; x++) {
                        // È†ÇÁÇπ„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπË®àÁÆóÔºàPlaneGeometry„ÅÆÈ†ÇÁÇπÈ†ÜÂ∫è„ÅØÂ∑¶‰∏ä„Åã„ÇâÂè≥‰∏ã„Åß„ÅØ„Å™„ÅÑ„ÅÆ„ÅßÊ≥®ÊÑè„ÅåÂøÖË¶Å„Å†„Åå„ÄÅ
                        // „Éá„Éï„Ç©„É´„Éà„Åß„ÅØ row-majorÔºâ
                        // YËª∏„ÇíÂèçËª¢„Åï„Åõ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åã„ÇÇÁ¢∫Ë™ç
                        const i = (map.terrain.height - 1 - y) * map.terrain.width + x;

                        // È´ò„Åï„ÇíÈÅ©Áî® (ZËª∏)
                        const height = map.terrain.heightMap[y][x];
                        positionAttribute.setZ(i, height * 0.5); // „Çπ„Ç±„Éº„É´Ë™øÊï¥

                        // Âú∞ÂΩ¢Ëâ≤„ÇíÈÅ©Áî® (Vertex Colors)
                        const terrainId = map.terrain.terrainType[y][x];
                        const terrain = TERRAIN_TYPES[terrainId.toUpperCase()] || TERRAIN_TYPES.GRASS;
                        color.set(terrain.color);

                        // È´ò„Åï„Å´Âøú„Åò„Å¶Â∞ë„ÅóÊöó„Åè/Êòé„Çã„Åè
                        if (height > 5) color.multiplyScalar(1.2);
                        else if (height < 2) color.multiplyScalar(0.8);

                        colors.push(color.r, color.g, color.b);
                    }
                }

                // È†ÇÁÇπ„Ç´„É©„ÉºË®≠ÂÆöÔºàÈ†ÇÁÇπÊï∞„Å®‰∏ÄËá¥„Åï„Åõ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅÂÜçË®àÁÆóÔºâ
                // PlaneGeometry„ÅÆÈ†ÇÁÇπÊï∞„ÅØ (w+1)*(h+1) „Å™„ÅÆ„Åß„ÄÅ‰∏äË®ò„É´„Éº„Éó„Å®„ÅØÂêà„Çè„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„ÄÇ
                // Á∞°ÊòìÁöÑ„Å´„ÄÅ„Éû„ÉÜ„É™„Ç¢„É´„Ç´„É©„Éº„ÅÆ„Åø„ÅßË°å„Åè„Åã„ÄÅ„Ç≠„É£„É≥„Éê„Çπ„Çí„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å®„Åó„Å¶Ë≤º„Çã„ÅÆ„ÅåÁ¢∫ÂÆü

                // „Ç≠„É£„É≥„Éê„Çπ„Åã„Çâ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÁîüÊàê„Åó„Å¶Ë≤º„ÇãÊñπÂºè„Å´Â§âÊõ¥
                const texture = new THREE.CanvasTexture(this.canvas);
                texture.magFilter = THREE.NearestFilter;

                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    flatShading: true,
                    roughness: 0.8,
                    metalness: 0.2
                });

                // È†ÇÁÇπ„ÅÆÈ´ò„Åï„ÇíÂÜçË®≠ÂÆö
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = i % (map.terrain.width); // width„Çª„Ç∞„É°„É≥„ÉàÊï∞ + 1 „Åß„ÅØ„Å™„ÅÑÔºü
                    // PlaneGeometry(w, h, ws, hs) -> ws+1, hs+1 vertices
                    // ÂçòÁ¥îÂåñ„ÅÆ„Åü„ÇÅ„ÄÅCanvasTextureÊñπÂºè„ÇíÊé°Áî®„Åó„ÄÅÈ´ò„Åï„Å†„ÅëÂêà„Çè„Åõ„Çã

                    // „Ç∞„É™„ÉÉ„ÉâÂ∫ßÊ®ô„Å∏„ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞Ëøë‰ºº
                    const gridX = Math.floor((positionAttribute.getX(i) + map.terrain.width / 2));
                    const gridY = Math.floor((-positionAttribute.getY(i) + map.terrain.height / 2));

                    if (gridX >= 0 && gridX < map.terrain.width && gridY >= 0 && gridY < map.terrain.height) {
                        const h = map.terrain.heightMap[gridY][gridX];
                        positionAttribute.setZ(i, h * 0.5);
                    }
                }

                positionAttribute.needsUpdate = true;
                geometry.computeVertexNormals();

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2; // ÂØù„Åã„Åõ„Çã
                this.scene3d.add(this.mesh);

                // Âª∫Áâ©„ÅÆÊèèÁîª (Voxel InstancedMesh)
                if (this.buildingGroup) {
                    this.scene3d.remove(this.buildingGroup);
                    // Dispose logic simplified
                    this.buildingGroup.children.forEach(mesh => {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                    });
                }
                this.buildingGroup = new THREE.Group();
                this.scene3d.add(this.buildingGroup);

                if (map.buildings && map.buildings.length > 0) {
                    // 1. ÂêÑ„Éñ„É≠„ÉÉ„ÇØ„Çø„Ç§„Éó„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÊï∞„Çí„Ç´„Ç¶„É≥„Éà
                    const counts = {};
                    map.buildings.forEach(b => {
                        const template = BUILDING_TEMPLATES[b.type];
                        if (!template || !template.blocks) return;

                        // blocks[z][y][x]
                        for (let z = 0; z < template.size.z; z++) {
                            for (let y = 0; y < template.size.y; y++) {
                                for (let x = 0; x < template.size.x; x++) {
                                    // ÁØÑÂõ≤„ÉÅ„Çß„ÉÉ„ÇØ (undefinedÈÅø„Åë)
                                    if (!template.blocks[z] || !template.blocks[z][y]) continue;
                                    const type = template.blocks[z][y][x];
                                    if (type !== BLOCK_TYPES.AIR && type !== undefined) {
                                        counts[type] = (counts[type] || 0) + 1;
                                    }
                                }
                            }
                        }
                    });

                    // 2. InstancedMesh„ÅÆ‰ΩúÊàê
                    const meshes = {};
                    const dummy = new THREE.Object3D();
                    const boxGeo = new THREE.BoxGeometry(1, 0.5, 1); // È´ò„Åï0.5„Çπ„Ç±„Éº„É´

                    Object.keys(counts).forEach(type => {
                        const count = counts[type];
                        const color = BLOCK_COLORS[type] || 0xFF00FF;
                        const mat = new THREE.MeshStandardMaterial({ color: color });
                        meshes[type] = new THREE.InstancedMesh(boxGeo, mat, count);
                        meshes[type].count = 0;
                        this.buildingGroup.add(meshes[type]);
                    });

                    // 3. „Ç§„É≥„Çπ„Çø„É≥„ÇπÈÖçÁΩÆ
                    map.buildings.forEach(b => {
                        const template = BUILDING_TEMPLATES[b.type];
                        if (!template || !template.blocks) return;

                        const bx = b.x;
                        const by = b.y;
                        const rot = b.rotation || 0;

                        // Âú∞ÂΩ¢„ÅÆÈ´ò„Åï (Âª∫Áâ©Âü∫Ê∫ñ‰ΩçÁΩÆ)
                        let groundH = 0;
                        if (bx >= 0 && bx < map.terrain.width && by >= 0 && by < map.terrain.height) {
                            groundH = map.terrain.heightMap[by][bx] * 0.5;
                        }

                        // ÂõûËª¢Âæå„ÅÆ„Çµ„Ç§„Ç∫ (LoopÁî®)
                        // ÂÖÉ„ÅÆ„É´„Éº„ÉóÁØÑÂõ≤„ÅØ x:0..Tx, y:0..Ty
                        // Â∫ßÊ®ôÂ§âÊèõ„É≠„Ç∏„ÉÉ„ÇØ„ÅßÂØæÂøú„Åô„Çã

                        const Tx = template.size.x;
                        const Ty = template.size.y;
                        const Tz = template.size.z;

                        for (let z = 0; z < Tz; z++) {
                            for (let y = 0; y < Ty; y++) {
                                for (let x = 0; x < Tx; x++) {
                                    // ÁØÑÂõ≤„ÉÅ„Çß„ÉÉ„ÇØ
                                    if (!template.blocks[z] || !template.blocks[z][y]) continue;
                                    const type = template.blocks[z][y][x];
                                    if (type === BLOCK_TYPES.AIR || type === undefined) continue;

                                    const mesh = meshes[type];
                                    if (!mesh) continue;

                                    const idx = mesh.count++;

                                    // ÂõûËª¢Â∫ßÊ®ôÂ§âÊèõ
                                    // Local(0,0) -> Rotated(0,0) (Top-Left based)
                                    // Rot 0: x'=x, y'=y
                                    // Rot 1: x'=Ty-1-y, y'=x
                                    // Rot 2: x'=Tx-1-x, y'=Ty-1-y
                                    // Rot 3: x'=y, y'=Tx-1-x

                                    let rx, ry;
                                    switch (rot) {
                                        case 0: rx = x; ry = y; break;
                                        case 1: rx = Ty - 1 - y; ry = x; break;
                                        case 2: rx = Tx - 1 - x; ry = Ty - 1 - y; break;
                                        case 3: rx = y; ry = Tx - 1 - x; break;
                                    }

                                    const wx = (bx + rx) - map.terrain.width / 2 + 0.5;
                                    const wz = -((by + ry) - map.terrain.height / 2 + 0.5);
                                    const wy = groundH + (z * 0.5) + 0.25;

                                    dummy.position.set(wx, wy, wz);
                                    dummy.rotation.set(0, 0, 0); // VoxelËá™‰Ωì„ÅØÂõûËª¢‰∏çË¶Å„ÄÅ„ÅÇ„Çã„ÅÑ„ÅØ„ÉÜ„ÇØ„Çπ„ÉÅ„É£Âêë„Åç„ÅÆ„Åü„ÇÅ„Å´ÂõûËª¢ÂøÖË¶Å„Å†„ÅåÂçòËâ≤„Å™„ÅÆ„Åß‰∏çË¶Å
                                    dummy.scale.set(1, 1, 1);
                                    dummy.updateMatrix();
                                    mesh.setMatrixAt(idx, dummy.matrix);
                                }
                            }
                        }
                    });

                    Object.values(meshes).forEach(m => m.instanceMatrix.needsUpdate = true);
                }

                this.fitCameraToMesh(map);
            }

            togglePreviewExpand() {
                const container = document.getElementById('preview-3d');
                container.classList.toggle('expanded');
                const isExpanded = container.classList.contains('expanded');

                const btn = document.getElementById('view-expand');
                btn.textContent = isExpanded ? 'Á∏ÆÂ∞è' : '‚§¢';
                btn.classList.toggle('active', isExpanded);

                requestAnimationFrame(() => {
                    const width = container.clientWidth;
                    const height = container.clientHeight - 30; // header height

                    if (this.renderer3d && this.camera3d) {
                        this.renderer3d.setSize(width, height);
                        this.camera3d.aspect = width / height;
                        this.camera3d.updateProjectionMatrix();
                        this.update3DPreview();
                    }
                });
            }

            update3DPreviewDebounced() {
                if (this.previewTimeout) clearTimeout(this.previewTimeout);
                this.previewTimeout = setTimeout(() => this.update3DPreview(), 500);
            }

            set3DView(type) {
                this.currentView = type;
                if (!this.camera3d || !this.currentMapId) return;

                const map = mapRepository.get(this.currentMapId);
                this.fitCameraToMesh(map);
            }

            rotate3DView() {
                this.viewRotation = (this.viewRotation + 1) % 4;
                this.fitCameraToMesh(mapRepository.get(this.currentMapId));
            }

            fitCameraToMesh(map) {
                if (!map || !this.camera3d) return;

                const size = Math.max(map.terrain.width, map.terrain.height);

                if (this.currentView === 'perspective') {
                    // 90Â∫¶„Åî„Å®„ÅÆË¶ñÁÇπ‰ΩçÁΩÆË®àÁÆó
                    const angle = this.viewRotation * (Math.PI / 2); // 0, 90, 180, 270 deg
                    const dist = size * 1.2;
                    // ‰∏≠ÂøÉ(0,0,0)„Åã„Çâ„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà
                    const x = Math.sin(angle) * dist + Math.cos(angle) * dist;
                    const z = Math.cos(angle) * dist - Math.sin(angle) * dist;

                    // „Çà„Çä„ÄåÂõõÈöÖ„Äç„Åã„Çâ„ÅÆË¶ñÁÇπ„Å´„Åô„Çã„Åü„ÇÅË™øÊï¥
                    // ÂåóË•ø(0): (-size, size, -size) -> x+, z+
                    // ÂåóÊù±(1): (size, size, -size) -> ??
                    // „Ç∑„É≥„Éó„É´„Å´ÂõûËª¢Ë°åÂàó„ÅßËÄÉ„Åà„Çã
                    // Base pos: (size, size, size) [ÂçóÊù±]

                    const baseDist = size;

                    /*
                        Rotation 0 (SE): x+, z+
                        Rotation 1 (SW): x-, z+
                        Rotation 2 (NW): x-, z-
                        Rotation 3 (NE): x+, z-
                    */

                    let camX, camZ;
                    switch (this.viewRotation) {
                        case 0: camX = baseDist; camZ = baseDist; break; // SE
                        case 1: camX = -baseDist; camZ = baseDist; break; // SW
                        case 2: camX = -baseDist; camZ = -baseDist; break; // NW
                        case 3: camX = baseDist; camZ = -baseDist; break; // NE
                    }

                    this.camera3d.position.set(camX, size * 0.8, camZ);
                    this.camera3d.lookAt(0, 0, 0);
                } else {
                    this.camera3d.position.set(0, size * 1.5, 0);
                    this.camera3d.lookAt(0, 0, 0);

                    // Áúü‰∏äË¶ñÁÇπ„ÅÆÂ†¥Âêà„ÅØÂåó„Çí‰∏ä„Å´Âõ∫ÂÆö„ÄÅ„ÅÇ„Çã„ÅÑ„ÅØÁèæÂú®„ÅÆÂõûËª¢„Å´Âêà„Çè„Åõ„Çã„Åã
                    // „É¶„Éº„Ç∂„ÉºË¶ÅÊúõ„ÅØ„ÄåÂõõÊñπÂêë„ÅÆËßí„ÅÆÊñú„ÇÅË¶ã‰∏ã„Çç„Åó„Äç„Å™„ÅÆ„Åß„ÄÅTop„Éì„É•„Éº„ÅØÂõ∫ÂÆö„ÅßËâØ„ÅÑ
                    this.camera3d.rotation.z = this.viewRotation * (Math.PI / 2);
                }
            }

            save3DPreviewImage() {
                // Â∞ÜÊù•ÁöÑ„Å´„Çµ„É†„Éç„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò
            }

            removeBuildingAt(x, y) {
                if (!this.currentMapId) return;
                const map = mapRepository.get(this.currentMapId);
                if (!map.buildings) return;

                const initialCount = map.buildings.length;
                map.buildings = map.buildings.filter(b => {
                    const template = BUILDING_TEMPLATES[b.type];
                    if (!template) return true;

                    const rot = b.rotation || 0;
                    const isRotated = rot % 2 !== 0;
                    const w = isRotated ? template.size.y : template.size.x;
                    const h = isRotated ? template.size.x : template.size.y;

                    // ÁØÑÂõ≤„ÉÅ„Çß„ÉÉ„ÇØ (b.x, b.y) „Åã„Çâ (b.x + w, b.y + h)
                    const insideX = x >= b.x && x < b.x + w;
                    const insideY = y >= b.y && y < b.y + h;

                    return !(insideX && insideY); // ÁØÑÂõ≤ÂÜÖ„Å™„ÇâÈô§Â§ñÔºàÂâäÈô§Ôºâ
                });

                if (map.buildings.length !== initialCount) {
                    console.log(`Removed ${initialCount - map.buildings.length} buildings at ${x},${y}`);
                    this.render();
                    this.update3DPreview();
                    return true;
                }
                return false;
            }
        }

        // ÂàùÊúüÂåñ
        const editor = new MapEditor();
    </script>
</body>

</html>